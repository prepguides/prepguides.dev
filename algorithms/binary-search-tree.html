<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Search Tree - PrepGuides.dev</title>
    <meta name="description" content="Interactive visualization of Binary Search Tree operations with insert, delete, search, and traversal animations">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #6366f1;
            --secondary: #8b5cf6;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --dark: #1f2937;
            --light: #f3f4f6;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .main-container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 24px;
            overflow: hidden;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
        }

        header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white;
            padding: 40px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .back-button {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            text-decoration: none;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .back-button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        h1 {
            font-size: 3rem;
            font-weight: 800;
            margin-bottom: 1rem;
            position: relative;
            z-index: 1;
        }

        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            position: relative;
            z-index: 1;
        }

        .content {
            padding: 40px;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 30px;
            align-items: center;
            justify-content: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: center;
        }

        .control-group label {
            font-weight: 600;
            color: var(--dark);
            font-size: 0.9rem;
        }

        select, input, button {
            padding: 12px 16px;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            font-size: 1rem;
            transition: all 0.3s ease;
            background: white;
        }

        select:focus, input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }

        button {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
            min-width: 120px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(99, 102, 241, 0.3);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .visualization {
            background: #f8fafc;
            border-radius: 16px;
            padding: 30px;
            margin-bottom: 30px;
            border: 2px solid #e2e8f0;
            min-height: 400px;
        }

        .visualization-area {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
            min-height: 400px;
            position: relative;
            overflow: auto;
        }

        .tree-container {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 350px;
            padding: 20px;
        }

        .tree-node {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            margin: 10px;
            position: relative;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .tree-node.highlighted {
            background: var(--warning);
            transform: scale(1.2);
            box-shadow: 0 0 20px rgba(245, 158, 11, 0.5);
        }

        .tree-node.visited {
            background: var(--success);
        }

        .tree-node.found {
            background: var(--danger);
            animation: pulse 1s infinite;
        }

        .tree-node.new {
            background: var(--secondary);
            animation: bounce 0.6s ease;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            60% { transform: translateY(-5px); }
        }

        .tree-level {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 20px 0;
        }

        .tree-line {
            position: absolute;
            background: #6b7280;
            height: 2px;
            transform-origin: left center;
        }

        .tree-line.horizontal {
            width: 50px;
        }

        .tree-line.vertical {
            width: 2px;
            height: 30px;
        }

        .traversal-result {
            background: #f8fafc;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            border: 1px solid #e5e7eb;
        }

        .traversal-result h4 {
            color: var(--dark);
            margin-bottom: 10px;
        }

        .traversal-sequence {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .traversal-item {
            background: var(--primary);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            border: 1px solid #e5e7eb;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 800;
            color: var(--primary);
            margin-bottom: 8px;
        }

        .stat-label {
            color: #6b7280;
            font-weight: 500;
        }

        .algorithm-info {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            border: 1px solid #e5e7eb;
        }

        .algorithm-info h3 {
            color: var(--dark);
            margin-bottom: 15px;
            font-size: 1.5rem;
        }

        .complexity {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .complexity-item {
            text-align: center;
            padding: 15px;
            background: #f8fafc;
            border-radius: 8px;
        }

        .complexity-item h4 {
            color: var(--dark);
            margin-bottom: 5px;
            font-size: 0.9rem;
        }

        .complexity-item p {
            color: var(--primary);
            font-weight: 700;
            font-size: 1.1rem;
        }

        .description {
            color: #6b7280;
            line-height: 1.6;
            margin-bottom: 20px;
        }

        .interview-questions {
            background: #f8fafc;
            border-radius: 16px;
            padding: 30px;
            margin-top: 30px;
        }

        .interview-questions h3 {
            color: var(--dark);
            margin-bottom: 20px;
            font-size: 1.5rem;
        }

        .question-category {
            margin-bottom: 25px;
        }

        .question-category h4 {
            color: var(--primary);
            margin-bottom: 10px;
            font-size: 1.1rem;
        }

        .question-category ul {
            list-style: none;
            padding-left: 0;
        }

        .question-category li {
            background: white;
            padding: 12px 16px;
            margin-bottom: 8px;
            border-radius: 8px;
            border-left: 4px solid var(--primary);
            color: #6b7280;
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: stretch;
            }

            .control-group {
                align-items: stretch;
            }

            h1 {
                font-size: 2rem;
            }

            .content {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <header>
            <a href="algorithms.html" class="back-button">‚Üê Back to Algorithms</a>
            <h1>Binary Search Tree</h1>
            <p class="subtitle">Interactive BST operations with insert, delete, search, and traversal</p>
        </header>

        <div class="content">
            <div class="controls">
                <div class="control-group">
                    <label for="operation">Operation</label>
                    <select id="operation">
                        <option value="insert">Insert</option>
                        <option value="delete">Delete</option>
                        <option value="search">Search</option>
                        <option value="traverse">Traverse</option>
                    </select>
                </div>

                <div class="control-group">
                    <label for="value">Value</label>
                    <input type="number" id="value" placeholder="Enter value..." min="1" max="99">
                </div>

                <div class="control-group">
                    <label for="traversal">Traversal Type</label>
                    <select id="traversal">
                        <option value="inorder">Inorder</option>
                        <option value="preorder">Preorder</option>
                        <option value="postorder">Postorder</option>
                        <option value="levelorder">Level Order</option>
                    </select>
                </div>

                <div class="control-group">
                    <label for="speed">Speed</label>
                    <input type="range" id="speed" min="1" max="10" value="5">
                    <span id="speedValue">5</span>
                </div>

                <div class="control-group">
                    <button id="execute">Execute</button>
                    <button id="generate">Generate Random</button>
                    <button id="reset">Reset</button>
                </div>
            </div>

            <div class="visualization">
                <div class="visualization-area" id="visualizationArea">
                    <!-- Algorithm visualization will be rendered here -->
                    <p style="color: #6b7280; font-size: 1.1rem;">Algorithm visualization will appear here</p>
                </div>
            </div>

            <div class="stats">
                <div class="stat-card">
                    <div class="stat-value" id="operations">0</div>
                    <div class="stat-label">Operations</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="comparisons">0</div>
                    <div class="stat-label">Comparisons</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="time">0ms</div>
                    <div class="stat-label">Time</div>
                </div>
            </div>

            <div class="algorithm-info">
                <h3>Binary Search Tree</h3>
                <div class="complexity">
                    <div class="complexity-item">
                        <h4>Search Time</h4>
                        <p>O(log n) avg, O(n) worst</p>
                    </div>
                    <div class="complexity-item">
                        <h4>Insert/Delete</h4>
                        <p>O(log n) avg, O(n) worst</p>
                    </div>
                    <div class="complexity-item">
                        <h4>Space</h4>
                        <p>O(n)</p>
                    </div>
                </div>
                <div class="description">
                    A Binary Search Tree (BST) is a binary tree where each node has at most two children, and for each node, all values in the left subtree are less than the node's value, and all values in the right subtree are greater than the node's value. This property enables efficient search, insertion, and deletion operations.
                </div>
            </div>

            <div class="interview-questions">
                <h3>Interview Questions</h3>
                
                <div class="question-category">
                    <h4>Basic Concepts</h4>
                    <ul>
                        <li>What is a Binary Search Tree and how does it work?</li>
                        <li>What are the properties of a valid BST?</li>
                        <li>What's the difference between BST and binary tree?</li>
                        <li>How do you validate if a binary tree is a BST?</li>
                    </ul>
                </div>

                <div class="question-category">
                    <h4>Operations</h4>
                    <ul>
                        <li>Implement BST insert, delete, and search operations</li>
                        <li>How do you find the minimum and maximum values in a BST?</li>
                        <li>Implement inorder, preorder, and postorder traversals</li>
                        <li>How do you find the kth smallest element in a BST?</li>
                    </ul>
                </div>

                <div class="question-category">
                    <h4>Advanced Topics</h4>
                    <ul>
                        <li>What causes BST to become unbalanced?</li>
                        <li>How do you convert a sorted array to a balanced BST?</li>
                        <li>Implement BST iterator for inorder traversal</li>
                        <li>How do you find the lowest common ancestor in a BST?</li>
                    </ul>
                </div>

                <div class="question-category">
                    <h4>Time Complexity</h4>
                    <ul>
                        <li>What's the time complexity of BST operations?</li>
                        <li>When does BST have O(n) time complexity?</li>
                        <li>How can you maintain O(log n) operations?</li>
                        <li>Compare BST with hash table for search operations</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        class BSTNode {
            constructor(value) {
                this.value = value;
                this.left = null;
                this.right = null;
                this.id = Math.random().toString(36).substr(2, 9);
            }
        }

        class BSTVisualizer {
            constructor() {
                this.root = null;
                this.isRunning = false;
                this.operations = 0;
                this.comparisons = 0;
                this.startTime = 0;
                this.traversalSequence = [];
                
                this.initializeElements();
                this.setupEventListeners();
                this.resetStats();
                this.generateRandomTree();
            }

            initializeElements() {
                this.visualizationArea = document.getElementById('visualizationArea');
                this.operationSelect = document.getElementById('operation');
                this.valueInput = document.getElementById('value');
                this.traversalSelect = document.getElementById('traversal');
                this.speedSlider = document.getElementById('speed');
                this.executeBtn = document.getElementById('execute');
                this.generateBtn = document.getElementById('generate');
                this.resetBtn = document.getElementById('reset');
                this.speedValue = document.getElementById('speedValue');
                this.operationsEl = document.getElementById('operations');
                this.comparisonsEl = document.getElementById('comparisons');
                this.timeEl = document.getElementById('time');
            }

            setupEventListeners() {
                this.executeBtn.addEventListener('click', () => this.executeOperation());
                this.generateBtn.addEventListener('click', () => this.generateRandomTree());
                this.resetBtn.addEventListener('click', () => this.reset());
                this.speedSlider.addEventListener('input', (e) => {
                    this.speedValue.textContent = e.target.value;
                });
                this.operationSelect.addEventListener('change', () => this.updateControls());
            }

            updateControls() {
                const operation = this.operationSelect.value;
                const valueInput = document.getElementById('value');
                const traversalSelect = document.getElementById('traversal');
                
                if (operation === 'traverse') {
                    valueInput.style.display = 'none';
                    traversalSelect.style.display = 'block';
                } else {
                    valueInput.style.display = 'block';
                    traversalSelect.style.display = 'none';
                }
            }

            generateRandomTree() {
                this.root = null;
                const values = [50, 25, 75, 12, 37, 62, 87, 6, 18, 31, 43, 56, 68, 81, 93];
                values.forEach(value => {
                    this.root = this.insertNode(this.root, value);
                });
                this.renderTree();
                this.resetStats();
            }

            insertNode(node, value) {
                if (!node) {
                    return new BSTNode(value);
                }
                
                if (value < node.value) {
                    node.left = this.insertNode(node.left, value);
                } else if (value > node.value) {
                    node.right = this.insertNode(node.right, value);
                }
                
                return node;
            }

            async executeOperation() {
                if (this.isRunning) return;
                
                this.isRunning = true;
                this.executeBtn.disabled = true;
                this.resetStats();
                this.startTime = performance.now();

                const operation = this.operationSelect.value;
                const value = parseInt(this.valueInput.value);

                try {
                    switch (operation) {
                        case 'insert':
                            if (value && value >= 1 && value <= 99) {
                                await this.insert(value);
                            }
                            break;
                        case 'delete':
                            if (value && value >= 1 && value <= 99) {
                                await this.delete(value);
                            }
                            break;
                        case 'search':
                            if (value && value >= 1 && value <= 99) {
                                await this.search(value);
                            }
                            break;
                        case 'traverse':
                            await this.traverse();
                            break;
                    }
                } finally {
                    this.isRunning = false;
                    this.executeBtn.disabled = false;
                }
            }

            async insert(value) {
                this.operations++;
                this.updateStats();
                
                if (!this.root) {
                    this.root = new BSTNode(value);
                    this.renderTree();
                    await this.highlightNode(this.root.id, 'new');
                    return;
                }

                await this.insertHelper(this.root, value);
                this.renderTree();
            }

            async insertHelper(node, value) {
                this.comparisons++;
                this.updateStats();
                
                await this.highlightNode(node.id, 'highlighted');
                await this.sleep(1000 / this.speedSlider.value * 10);

                if (value < node.value) {
                    if (!node.left) {
                        node.left = new BSTNode(value);
                        await this.highlightNode(node.left.id, 'new');
                    } else {
                        await this.insertHelper(node.left, value);
                    }
                } else if (value > node.value) {
                    if (!node.right) {
                        node.right = new BSTNode(value);
                        await this.highlightNode(node.right.id, 'new');
                    } else {
                        await this.insertHelper(node.right, value);
                    }
                }
            }

            async search(value) {
                this.operations++;
                this.updateStats();
                
                const found = await this.searchHelper(this.root, value);
                if (found) {
                    await this.highlightNode(found.id, 'found');
                } else {
                    // Show not found message
                    this.visualizationArea.innerHTML += '<div style="text-align: center; color: var(--danger); margin-top: 20px;">Value not found!</div>';
                    setTimeout(() => this.renderTree(), 2000);
                }
            }

            async searchHelper(node, value) {
                if (!node) return null;
                
                this.comparisons++;
                this.updateStats();
                
                await this.highlightNode(node.id, 'highlighted');
                await this.sleep(1000 / this.speedSlider.value * 10);

                if (value === node.value) {
                    return node;
                } else if (value < node.value) {
                    return await this.searchHelper(node.left, value);
                } else {
                    return await this.searchHelper(node.right, value);
                }
            }

            async traverse() {
                this.operations++;
                this.updateStats();
                
                this.traversalSequence = [];
                const traversalType = this.traversalSelect.value;
                
                switch (traversalType) {
                    case 'inorder':
                        await this.inorderTraversal(this.root);
                        break;
                    case 'preorder':
                        await this.preorderTraversal(this.root);
                        break;
                    case 'postorder':
                        await this.postorderTraversal(this.root);
                        break;
                    case 'levelorder':
                        await this.levelOrderTraversal(this.root);
                        break;
                }
                
                this.showTraversalResult();
            }

            async inorderTraversal(node) {
                if (!node) return;
                
                await this.inorderTraversal(node.left);
                await this.highlightNode(node.id, 'visited');
                this.traversalSequence.push(node.value);
                await this.sleep(1000 / this.speedSlider.value * 10);
                await this.inorderTraversal(node.right);
            }

            async preorderTraversal(node) {
                if (!node) return;
                
                await this.highlightNode(node.id, 'visited');
                this.traversalSequence.push(node.value);
                await this.sleep(1000 / this.speedSlider.value * 10);
                await this.preorderTraversal(node.left);
                await this.preorderTraversal(node.right);
            }

            async postorderTraversal(node) {
                if (!node) return;
                
                await this.postorderTraversal(node.left);
                await this.postorderTraversal(node.right);
                await this.highlightNode(node.id, 'visited');
                this.traversalSequence.push(node.value);
                await this.sleep(1000 / this.speedSlider.value * 10);
            }

            async levelOrderTraversal(node) {
                if (!node) return;
                
                const queue = [node];
                
                while (queue.length > 0) {
                    const current = queue.shift();
                    await this.highlightNode(current.id, 'visited');
                    this.traversalSequence.push(current.value);
                    await this.sleep(1000 / this.speedSlider.value * 10);
                    
                    if (current.left) queue.push(current.left);
                    if (current.right) queue.push(current.right);
                }
            }

            showTraversalResult() {
                const resultDiv = document.createElement('div');
                resultDiv.className = 'traversal-result';
                resultDiv.innerHTML = `
                    <h4>${this.traversalSelect.value.charAt(0).toUpperCase() + this.traversalSelect.value.slice(1)} Traversal Result:</h4>
                    <div class="traversal-sequence">
                        ${this.traversalSequence.map(val => `<span class="traversal-item">${val}</span>`).join('')}
                    </div>
                `;
                this.visualizationArea.appendChild(resultDiv);
            }

            async highlightNode(nodeId, className) {
                const node = document.getElementById(nodeId);
                if (node) {
                    node.classList.add(className);
                    await this.sleep(500);
                    node.classList.remove(className);
                }
            }

            renderTree() {
                this.visualizationArea.innerHTML = '<div class="tree-container" id="treeContainer"></div>';
                const container = document.getElementById('treeContainer');
                
                if (this.root) {
                    this.renderNode(this.root, container, 0, 0);
                } else {
                    container.innerHTML = '<p style="color: #6b7280; text-align: center;">Tree is empty</p>';
                }
            }

            renderNode(node, container, level, position) {
                if (!node) return;
                
                const nodeDiv = document.createElement('div');
                nodeDiv.className = 'tree-node';
                nodeDiv.id = node.id;
                nodeDiv.textContent = node.value;
                nodeDiv.style.marginLeft = `${position * 60}px`;
                nodeDiv.style.marginTop = `${level * 80}px`;
                
                container.appendChild(nodeDiv);
                
                if (node.left) {
                    this.renderNode(node.left, container, level + 1, position - 1);
                }
                if (node.right) {
                    this.renderNode(node.right, container, level + 1, position + 1);
                }
            }

            reset() {
                this.isRunning = false;
                this.executeBtn.disabled = false;
                this.resetStats();
                this.traversalSequence = [];
                this.root = null;
                this.renderTree();
            }

            async sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            resetStats() {
                this.operations = 0;
                this.comparisons = 0;
                this.operationsEl.textContent = '0';
                this.comparisonsEl.textContent = '0';
                this.timeEl.textContent = '0ms';
            }

            updateStats() {
                const currentTime = performance.now();
                const elapsed = Math.round(currentTime - this.startTime);
                this.timeEl.textContent = `${elapsed}ms`;
                this.operationsEl.textContent = this.operations;
                this.comparisonsEl.textContent = this.comparisons;
            }
        }

        // Initialize the visualizer when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new BSTVisualizer();
        });
    </script>
</body>
</html>
