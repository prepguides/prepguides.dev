<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trie Operations - PrepGuides.dev</title>
    <meta name="description" content="Interactive visualization of Trie (Prefix Tree) operations with insert, search, and delete functionality">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #1f2937;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .back-link {
            display: inline-block;
            margin-bottom: 20px;
            color: white;
            text-decoration: none;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            transition: background 0.3s ease;
        }

        .back-link:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .controls {
            background: white;
            border-radius: 16px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-items: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-group label {
            font-weight: 600;
            color: #374151;
            font-size: 0.9rem;
        }

        .operation-buttons {
            display: flex;
            gap: 10px;
        }

        .operation-btn {
            padding: 10px 20px;
            border: 2px solid #8b5cf6;
            background: #8b5cf6;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .operation-btn.active {
            background: #7c3aed;
            border-color: #7c3aed;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(139, 92, 246, 0.3);
        }

        .operation-btn:hover:not(.active) {
            background: #7c3aed;
            border-color: #7c3aed;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(139, 92, 246, 0.3);
        }

        input[type="text"] {
            padding: 12px 16px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #8b5cf6;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
        }

        button {
            padding: 12px 24px;
            background: #8b5cf6;
            color: white;
            border: 2px solid #8b5cf6;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        button:hover {
            background: #7c3aed;
            border-color: #7c3aed;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(139, 92, 246, 0.3);
        }

        button:disabled {
            background: #9ca3af;
            border-color: #9ca3af;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .visualization-area {
            display: flex;
            gap: 25px;
        }

        .trie-container {
            flex: 1;
            background: white;
            border-radius: 16px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            min-height: 500px;
            position: relative;
        }

        .word-list {
            width: 250px;
            background: white;
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            height: fit-content;
        }

        .word-list h3 {
            margin-bottom: 15px;
            color: #374151;
            font-size: 1.1rem;
        }

        .word-item {
            padding: 8px 12px;
            background: #f3f4f6;
            border-radius: 6px;
            margin-bottom: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }

        .step-info {
            background: #f0f9ff;
            border: 1px solid #0ea5e9;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            display: none;
        }

        .step-info h4 {
            color: #0c4a6e;
            margin-bottom: 5px;
        }

        .step-info p {
            color: #0c4a6e;
            font-size: 0.9rem;
        }

        .trie-help {
            background: #f0f9ff;
            border: 1px solid #0ea5e9;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            font-size: 0.9rem;
            color: #0c4a6e;
        }

        .trie-help p {
            margin: 0 0 10px 0;
            font-weight: 600;
        }

        .trie-help ul {
            margin: 0;
            padding-left: 20px;
        }

        .trie-help li {
            margin: 5px 0;
        }

        /* D3.js styles */
        .link {
            fill: none;
            stroke: #6b7280;
            stroke-width: 2px;
        }

        .node circle {
            stroke: #fff;
            stroke-width: 2px;
        }

        .node text {
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            font-weight: bold;
            fill: white;
        }

        .edge-label {
            font-family: 'Inter', sans-serif;
            font-size: 12px;
            fill: #374151;
            font-weight: 500;
        }

        .node.highlighted circle {
            stroke: #f59e0b;
            stroke-width: 3px;
        }

        .link.highlighted {
            stroke: #f59e0b;
            stroke-width: 3px;
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: stretch;
            }

            .operation-buttons {
                justify-content: center;
            }

            .action-buttons {
                justify-content: center;
                flex-wrap: wrap;
            }

            .visualization-area {
                flex-direction: column;
            }

            .word-list {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="../algorithms.html" class="back-link">‚Üê Back to Algorithms</a>
        
        <div class="header">
            <h1>Trie Operations</h1>
            <p>Interactive visualization of Trie (Prefix Tree) data structure operations</p>
        </div>

        <div class="controls">
            <div class="control-group">
                <label>Operation</label>
                <div class="operation-buttons">
                    <button class="operation-btn active" data-operation="insert">Insert</button>
                    <button class="operation-btn" data-operation="search">Search</button>
                    <button class="operation-btn" data-operation="delete">Delete</button>
                </div>
            </div>

            <div class="control-group">
                <label>Word</label>
                <input type="text" id="wordInput" placeholder="Enter word..." maxlength="10">
            </div>

            <div class="action-buttons">
                <button id="operationBtn">Insert Word</button>
                <button id="clearBtn">Clear Trie</button>
                <button id="centerBtn">Center Trie</button>
                <button id="resetViewBtn">Reset View</button>
            </div>
        </div>

        <div class="visualization-area">
            <div class="trie-container">
                <svg id="trieSvg" width="100%" height="500"></svg>
            </div>
            
            <div class="word-list">
                <h3>Words in Trie</h3>
                <div id="wordItems">
                    <!-- Words will be displayed here -->
                </div>
            </div>
        </div>

        <div class="step-info" id="stepInfo">
            <h4 id="stepTitle">Ready</h4>
            <p id="stepDescription">Select an operation and enter a word to get started.</p>
        </div>

        <div class="trie-help" id="trieHelp" style="display: none;">
            <p>üí° <strong>Navigation Tips:</strong></p>
            <ul>
                <li>üñ±Ô∏è <strong>Drag</strong> to move around the trie</li>
                <li>üîÑ <strong>Scroll</strong> to zoom in/out</li>
                <li>üéØ <strong>Center Trie</strong> to reset position</li>
                <li>üîÑ <strong>Reset View</strong> to start over</li>
            </ul>
        </div>
    </div>

    <script>
        class TrieNode {
            constructor(char) {
                this.char = char;
                this.children = new Map();
                this.isEndOfWord = false;
                this.id = Math.random().toString(36).substr(2, 9);
            }
        }

        class TrieVisualization {
            constructor() {
                this.root = new TrieNode('ROOT');
                this.currentOperation = 'insert';
                this.isRunning = false;
                this.animationSpeed = 800;
                this.words = new Set();
                this.nodeIdCounter = 0;
                
                // D3.js setup
                this.svg = d3.select('#trieSvg');
                this.width = 800;
                this.height = 500;
                this.zoom = d3.zoom()
                    .scaleExtent([0.1, 4])
                    .on('zoom', (event) => {
                        this.g.attr('transform', event.transform);
                    });
                
                this.svg.call(this.zoom);
                this.g = this.svg.append('g');
                
                this.initializeEventListeners();
                this.renderTrie();
            }

            initializeEventListeners() {
                // Operation buttons
                document.querySelectorAll('.operation-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.operation-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.currentOperation = btn.dataset.operation;
                        document.getElementById('operationBtn').textContent = 
                            this.currentOperation.charAt(0).toUpperCase() + this.currentOperation.slice(1) + ' Word';
                    });
                });

                // Main operation button
                document.getElementById('operationBtn').addEventListener('click', () => {
                    this.performOperation();
                });

                // Clear button
                document.getElementById('clearBtn').addEventListener('click', () => {
                    this.clearTrie();
                });

                // Center button
                document.getElementById('centerBtn').addEventListener('click', () => {
                    this.centerTrie();
                });

                // Reset view button
                document.getElementById('resetViewBtn').addEventListener('click', () => {
                    this.resetView();
                });

                // Enter key support
                document.getElementById('wordInput').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.performOperation();
                    }
                });
            }

            async performOperation() {
                const word = document.getElementById('wordInput').value.toLowerCase().trim();
                
                if (!word) {
                    this.showError('Please enter a word');
                    return;
                }

                if (!/^[a-z]+$/.test(word)) {
                    this.showError('Please enter only lowercase letters');
                    return;
                }
                
                if (word.length > 10) {
                    this.showError('Word must be 10 characters or less');
                    return;
                }

                if (this.isRunning) return;
                this.isRunning = true;

                switch (this.currentOperation) {
                    case 'insert':
                        await this.insertWord(word);
                        break;
                    case 'search':
                        await this.searchWord(word);
                        break;
                    case 'delete':
                        await this.deleteWord(word);
                        break;
                }

                this.isRunning = false;
                document.getElementById('wordInput').value = '';
            }

            async insertWord(word) {
                this.updateStepInfo('Inserting Word', `Inserting "${word}" into the trie...`);
                
                let current = this.root;
                let path = [];
                
                for (let i = 0; i < word.length; i++) {
                    const char = word[i];
                    path.push(char);
                    
                    this.updateStepInfo('Processing Character', `Processing character "${char}" (position ${i + 1}/${word.length})`);
                    
                    if (!current.children.has(char)) {
                        const newNode = new TrieNode(char);
                        current.children.set(char, newNode);
                        this.updateStepInfo('Creating Node', `Creating new node for character "${char}"`);
                    } else {
                        this.updateStepInfo('Following Path', `Following existing path for character "${char}"`);
                    }
                    
                    current = current.children.get(char);
                    
                    await this.delay(this.animationSpeed);
                    this.renderTrie();
                }
                
                current.isEndOfWord = true;
                this.words.add(word);
                this.updateStepInfo('Word Inserted', `Successfully inserted "${word}" into the trie`);
                
                this.renderTrie();
                this.updateWordList();
            }

            async searchWord(word) {
                this.updateStepInfo('Searching Word', `Searching for "${word}" in the trie...`);
                
                let current = this.root;
                let path = [];
                
                for (let i = 0; i < word.length; i++) {
                    const char = word[i];
                    path.push(char);
                    
                    this.updateStepInfo('Checking Character', `Checking character "${char}" (position ${i + 1}/${word.length})`);
                    
                    if (!current.children.has(char)) {
                        this.updateStepInfo('Word Not Found', `"${word}" not found in the trie`);
                        return false;
                    }
                    
                    current = current.children.get(char);
                    await this.delay(this.animationSpeed);
                }
                
                if (current.isEndOfWord) {
                    this.updateStepInfo('Word Found', `"${word}" found in the trie`);
                    return true;
                } else {
                    this.updateStepInfo('Word Not Found', `"${word}" not found in the trie`);
                    return false;
                }
            }

            async deleteWord(word) {
                this.updateStepInfo('Deleting Word', `Deleting "${word}" from the trie...`);
                
                if (!this.searchWordInTrie(word)) {
                    this.updateStepInfo('Word Not Found', `"${word}" not found in the trie. Cannot delete.`);
                    return false;
                }
                
                // Delete from trie structure
                this.deleteFromTrie(this.root, word, 0);
                this.words.delete(word);
                
                this.updateStepInfo('Word Deleted', `Successfully deleted "${word}" from the trie`);
                this.renderTrie();
                this.updateWordList();
                return true;
            }

            deleteFromTrie(node, word, index) {
                if (index === word.length) {
                    node.isEndOfWord = false;
                    return node.children.size === 0;
                }
                
                const char = word[index];
                if (!node.children.has(char)) {
                    return false;
                }
                
                const shouldDelete = this.deleteFromTrie(node.children.get(char), word, index + 1);
                
                if (shouldDelete) {
                    node.children.delete(char);
                    return node.children.size === 0 && !node.isEndOfWord;
                }
                
                return false;
            }

            searchWordInTrie(word) {
                let current = this.root;
                for (let i = 0; i < word.length; i++) {
                    const char = word[i];
                    if (!current.children.has(char)) {
                        return false;
                    }
                    current = current.children.get(char);
                }
                return current.isEndOfWord;
            }

            renderTrie() {
                // Clear existing content
                this.g.selectAll('*').remove();
                
                // Check if trie is empty
                if (this.root.children.size === 0) {
                    this.g.append('text')
                        .attr('x', this.width / 2)
                        .attr('y', this.height / 2)
                        .attr('text-anchor', 'middle')
                        .attr('font-size', '18px')
                        .attr('fill', '#6b7280')
                        .text('Trie is empty. Insert some words to see the visualization.');
                    return;
                }
                
                // Convert trie to D3 hierarchy
                const data = this.convertToD3Hierarchy();
                
                // Create tree layout
                const tree = d3.tree()
                    .size([this.width - 100, this.height - 100]);
                
                const root = d3.hierarchy(data);
                tree(root);
                
                // Render links
                this.g.selectAll('.link')
                    .data(root.links())
                    .enter()
                    .append('path')
                    .attr('class', 'link')
                    .attr('d', d3.linkVertical()
                        .x(d => d.x + 50)
                        .y(d => d.y + 50))
                    .style('fill', 'none')
                    .style('stroke', '#6b7280')
                    .style('stroke-width', 2);
                
                // Render nodes
                const nodes = this.g.selectAll('.node')
                    .data(root.descendants())
                    .enter()
                    .append('g')
                    .attr('class', 'node')
                    .attr('transform', d => `translate(${d.x + 50},${d.y + 50})`);
                
                // Add circles
                nodes.append('circle')
                    .attr('r', 25)
                    .style('fill', d => {
                        if (d.data.name === 'ROOT') return '#ef4444';
                        return d.data.isEndOfWord ? '#10b981' : '#3b82f6';
                    })
                    .style('stroke', '#fff')
                    .style('stroke-width', 2);
                
                // Add text
                nodes.append('text')
                    .attr('dy', '.35em')
                    .attr('text-anchor', 'middle')
                    .style('fill', 'white')
                    .style('font-weight', 'bold')
                    .style('font-size', '14px')
                    .text(d => d.data.name);
                
                // Add edge labels
                this.g.selectAll('.edge-label')
                    .data(root.links())
                    .enter()
                    .append('text')
                    .attr('class', 'edge-label')
                    .attr('x', d => (d.source.x + d.target.x) / 2 + 50)
                    .attr('y', d => (d.source.y + d.target.y) / 2 + 50)
                    .attr('text-anchor', 'middle')
                    .attr('font-size', '12px')
                    .attr('fill', '#374151')
                    .text(d => d.target.data.edgeChar);
                
                // Show help text
                const helpElement = document.getElementById('trieHelp');
                if (helpElement) {
                    helpElement.style.display = 'block';
                }
            }

            convertToD3Hierarchy() {
                const convert = (node, edgeChar = '') => {
                    const result = {
                        name: node.char,
                        isEndOfWord: node.isEndOfWord,
                        edgeChar: edgeChar,
                        children: []
                    };
                    
                    for (const [char, child] of node.children) {
                        result.children.push(convert(child, char));
                    }
                    
                    return result;
                };
                
                return convert(this.root);
            }

            clearTrie() {
                this.root = new TrieNode('ROOT');
                this.words.clear();
                this.renderTrie();
                this.updateWordList();
                this.updateStepInfo('Trie Cleared', 'All words have been removed from the trie');
            }

            centerTrie() {
                if (this.root.children.size === 0) {
                    this.updateStepInfo('Cannot Center', 'Trie is empty. Insert some words first.');
                    return;
                }

                // Reset zoom and pan
                this.svg.transition().duration(750).call(
                    this.zoom.transform,
                    d3.zoomIdentity.translate(this.width / 2, this.height / 2).scale(1)
                );
                
                this.updateStepInfo('Trie Centered', 'Trie has been centered in the viewport');
            }

            resetView() {
                if (this.root.children.size === 0) {
                    this.updateStepInfo('Cannot Reset', 'Trie is empty. Insert some words first.');
                    return;
                }

                this.renderTrie();
                this.centerTrie();
                this.updateStepInfo('View Reset', 'Trie view has been reset to default position');
            }

            updateWordList() {
                const container = document.getElementById('wordItems');
                container.innerHTML = '';
                
                const sortedWords = Array.from(this.words).sort();
                sortedWords.forEach(word => {
                    const wordElement = document.createElement('div');
                    wordElement.className = 'word-item';
                    wordElement.textContent = word;
                    container.appendChild(wordElement);
                });
            }

            updateStepInfo(title, description) {
                document.getElementById('stepTitle').textContent = title;
                document.getElementById('stepDescription').textContent = description;
                document.getElementById('stepInfo').style.display = 'block';
            }

            showError(message) {
                const errorDiv = document.createElement('div');
                errorDiv.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: #ef4444;
                    color: white;
                    padding: 15px 20px;
                    border-radius: 8px;
                    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
                    z-index: 1000;
                    font-weight: 500;
                `;
                errorDiv.textContent = message;
                document.body.appendChild(errorDiv);
                
                setTimeout(() => {
                    if (errorDiv.parentNode) {
                        errorDiv.parentNode.removeChild(errorDiv);
                    }
                }, 3000);
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // Initialize the visualization
        const trieVisualization = new TrieVisualization();
    </script>
</body>
</html>
