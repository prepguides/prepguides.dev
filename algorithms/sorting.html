<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sorting Algorithms - PrepGuides.dev</title>
    <meta name="description" content="Interactive visualization of 6 sorting algorithms with real-time performance metrics">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="stylesheet" href="../algorithms/code/code-highlighting.css">
    <script src="../algorithms/code/code-execution-sync.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #6366f1;
            --secondary: #8b5cf6;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --dark: #1f2937;
            --light: #f3f4f6;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .main-container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 24px;
            overflow: hidden;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
        }

        header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white;
            padding: 40px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .back-button {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            text-decoration: none;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .back-button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        h1 {
            font-size: 3rem;
            font-weight: 800;
            margin-bottom: 1rem;
            position: relative;
            z-index: 1;
        }

        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            position: relative;
            z-index: 1;
        }

        .content {
            padding: 40px;
        }

        .controls {
            background: white;
            border-radius: 16px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            border: 1px solid #e5e7eb;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .control-group label {
            font-weight: 600;
            color: var(--dark);
            min-width: 100px;
        }

        select, input {
            padding: 10px 15px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
        }

        select:focus, input:focus {
            outline: none;
            border-color: var(--primary);
        }

        button {
            padding: 12px 24px;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        button:hover {
            background: var(--secondary);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        button:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .algorithm-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .algorithm-btn {
            padding: 10px 20px;
            border: 2px solid var(--primary);
            background: white;
            color: var(--primary);
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .algorithm-btn.active {
            background: var(--primary);
            color: white;
        }

        .algorithm-btn:hover:not(.active) {
            background: var(--primary);
            color: white;
        }

        .visualization-area {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            border: 1px solid #e5e7eb;
            min-height: 500px;
        }

        .array-container {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            min-height: 400px;
            position: relative;
        }

        /* D3.js styles */
        .bar {
            fill: var(--primary);
            stroke: white;
            stroke-width: 2px;
            transition: all 0.3s ease;
        }

        .bar.comparing {
            fill: var(--warning);
        }

        .bar.swapping {
            fill: var(--danger);
        }

        .bar.sorted {
            fill: var(--success);
        }

        .bar.pivot {
            fill: var(--secondary);
        }

        .bar-label {
            font: 12px sans-serif;
            text-anchor: middle;
            fill: var(--dark);
            font-weight: 600;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }

        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            border: 1px solid #e5e7eb;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 800;
            color: var(--primary);
            margin-bottom: 8px;
        }

        .stat-label {
            color: #6b7280;
            font-weight: 500;
        }

        .algorithm-info {
            background: #f8fafc;
            border: 2px solid var(--primary);
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
        }

        .algorithm-info h4 {
            color: var(--primary);
            margin-bottom: 10px;
        }

        .algorithm-info p {
            color: var(--dark);
            line-height: 1.6;
        }

        /* Code Execution Container Styles */
        .code-execution-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 30px;
        }

        .code-panel {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            border: 1px solid #e5e7eb;
        }

        .code-panel h3 {
            color: var(--primary);
            margin-bottom: 15px;
            font-size: 1.2rem;
            font-weight: 600;
        }

        .code-block {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
        }

        .performance-panel {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            border: 1px solid #e5e7eb;
        }

        .performance-panel h3 {
            color: var(--primary);
            margin-bottom: 15px;
            font-size: 1.2rem;
            font-weight: 600;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .metric-card {
            background: #f8fafc;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid #e5e7eb;
        }

        .metric-label {
            font-size: 0.9rem;
            color: #6b7280;
            margin-bottom: 5px;
        }

        .metric-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary);
        }

        .complexity-analysis {
            border-top: 1px solid #e5e7eb;
            padding-top: 15px;
        }

        .complexity-analysis h4 {
            color: var(--secondary);
            margin-bottom: 10px;
            font-size: 1.1rem;
        }

        .complexity-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .complexity-item {
            background: #f8fafc;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #e5e7eb;
        }

        .complexity-type {
            font-size: 0.9rem;
            color: #6b7280;
            margin-bottom: 5px;
        }

        .complexity-value {
            font-size: 1rem;
            font-weight: 600;
            color: var(--dark);
        }

        .execution-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-top: 20px;
            padding: 15px;
            background: #f8fafc;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
        }

        .control-button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .control-button.primary {
            background: var(--primary);
            color: white;
        }

        .control-button.secondary {
            background: var(--warning);
            color: white;
        }

        .control-button.danger {
            background: var(--danger);
            color: white;
        }

        .control-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-left: auto;
        }

        .speed-control label {
            font-weight: 600;
            color: var(--dark);
        }

        .speed-slider {
            width: 100px;
        }

        .execution-progress {
            margin-top: 15px;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e5e7eb;
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            transition: width 0.3s ease;
        }

        .progress-text {
            text-align: center;
            margin-top: 8px;
            font-size: 0.9rem;
            color: #6b7280;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }
            
            .content {
                padding: 20px;
            }
            
            .control-group {
                flex-direction: column;
                align-items: stretch;
            }

            .code-execution-container {
                grid-template-columns: 1fr;
            }

            .execution-controls {
                flex-direction: column;
                align-items: stretch;
            }

            .speed-control {
                margin-left: 0;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <header>
            <a href="../algorithms.html" class="back-button">← Back to Algorithms</a>
            <h1>Sorting Algorithms</h1>
            <p class="subtitle">Interactive visualization of 6 sorting algorithms with real-time performance metrics</p>
        </header>

        <div class="content">
            <div class="controls">
                <div class="algorithm-buttons">
                    <button class="algorithm-btn active" data-algorithm="bubble">Bubble Sort</button>
                    <button class="algorithm-btn" data-algorithm="selection">Selection Sort</button>
                    <button class="algorithm-btn" data-algorithm="insertion">Insertion Sort</button>
                    <button class="algorithm-btn" data-algorithm="merge">Merge Sort</button>
                    <button class="algorithm-btn" data-algorithm="quick">Quick Sort</button>
                    <button class="algorithm-btn" data-algorithm="heap">Heap Sort</button>
                </div>

                <div class="control-group">
                    <label for="arraySize">Array Size:</label>
                    <input type="range" id="arraySize" min="5" max="50" value="20">
                    <span id="arraySizeValue">20</span>
                </div>

                <div class="control-group">
                    <label for="speed">Speed:</label>
                    <input type="range" id="speed" min="1" max="10" value="5">
                    <span id="speedValue">5</span>
                </div>

                <div class="control-group">
                    <button id="generate">Generate Array</button>
                    <button id="start">Start Sorting</button>
                    <button id="reset">Reset</button>
                </div>
            </div>

            <div class="visualization-area">
                <div class="array-container">
                    <svg id="arraySvg" width="100%" height="400"></svg>
                </div>
            </div>

            <div class="stats">
                <div class="stat-card">
                    <div class="stat-value" id="comparisons">0</div>
                    <div class="stat-label">Comparisons</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="swaps">0</div>
                    <div class="stat-label">Swaps</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="time">0ms</div>
                    <div class="stat-label">Time</div>
                </div>
            </div>

            <div class="algorithm-info" id="algorithmInfo">
                <h4>Bubble Sort</h4>
                <p>Bubble Sort repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order. Time Complexity: O(n²), Space Complexity: O(1)</p>
            </div>

            <!-- Code Execution Synchronization -->
            <div class="code-execution-container">
                <div class="code-panel go">
                    <h3>Go Implementation</h3>
                    <div id="goCodeBlock" class="code-block" data-language="go"></div>
                </div>
                <div class="code-panel java">
                    <h3>Java Implementation</h3>
                    <div id="javaCodeBlock" class="code-block" data-language="java"></div>
                </div>
            </div>

            <!-- Performance Metrics -->
            <div class="performance-panel">
                <h3>Performance Analysis</h3>
                <div class="metrics-grid">
                    <div class="metric-card comparisons">
                        <div class="metric-label">Total Comparisons</div>
                        <div class="metric-value" id="totalComparisons">0</div>
                    </div>
                    <div class="metric-card swaps">
                        <div class="metric-label">Total Swaps</div>
                        <div class="metric-value" id="totalSwaps">0</div>
                    </div>
                    <div class="metric-card operations">
                        <div class="metric-label">Operations</div>
                        <div class="metric-value" id="totalOperations">0</div>
                    </div>
                    <div class="metric-card duration">
                        <div class="metric-label">Duration (ms)</div>
                        <div class="metric-value" id="totalDuration">0</div>
                    </div>
                </div>
                
                <div class="complexity-analysis">
                    <h4>Complexity Analysis</h4>
                    <div class="complexity-grid">
                        <div class="complexity-item">
                            <div class="complexity-type">Time Complexity</div>
                            <div class="complexity-value" id="timeComplexity">O(n²)</div>
                        </div>
                        <div class="complexity-item">
                            <div class="complexity-type">Space Complexity</div>
                            <div class="complexity-value" id="spaceComplexity">O(1)</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Execution Controls -->
            <div class="execution-controls">
                <button class="control-button primary" onclick="startCodeExecution()">
                    ▶️ Start Code Sync
                </button>
                <button class="control-button secondary" onclick="pauseCodeExecution()">
                    ⏸️ Pause
                </button>
                <button class="control-button danger" onclick="stopCodeExecution()">
                    ⏹️ Stop
                </button>
                
                <div class="speed-control">
                    <label for="executionSpeed">Speed:</label>
                    <input type="range" id="executionSpeed" min="100" max="2000" value="1000" 
                           onchange="updateExecutionSpeed()" class="speed-slider">
                </div>
            </div>

            <div class="execution-progress">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                </div>
                <div class="progress-text" id="progressText">Ready to execute</div>
            </div>
        </div>
    </div>

    <script>
        class SortingVisualizer {
            constructor() {
                this.array = [];
                this.originalArray = [];
                this.currentAlgorithm = 'bubble';
                this.isRunning = false;
                this.comparisons = 0;
                this.swaps = 0;
                this.startTime = 0;
                this.speed = 5;
                
                // D3.js setup
                this.svg = d3.select('#arraySvg');
                this.width = 800;
                this.height = 400;
                this.margin = { top: 20, right: 20, bottom: 40, left: 20 };
                
                // Code execution synchronization
                this.codeSync = new CodeExecutionSync();
                this.initializeCodeBlocks();
                this.setupCodeEventListeners();
                
                this.initializeElements();
                this.setupEventListeners();
                this.generateArray();
            }

            initializeElements() {
                this.arraySizeInput = document.getElementById('arraySize');
                this.arraySizeValue = document.getElementById('arraySizeValue');
                this.speedInput = document.getElementById('speed');
                this.speedValue = document.getElementById('speedValue');
                this.generateBtn = document.getElementById('generate');
                this.startBtn = document.getElementById('start');
                this.resetBtn = document.getElementById('reset');
                this.comparisonsEl = document.getElementById('comparisons');
                this.swapsEl = document.getElementById('swaps');
                this.timeEl = document.getElementById('time');
                this.algorithmInfo = document.getElementById('algorithmInfo');
            }

            setupEventListeners() {
                // Algorithm buttons
                document.querySelectorAll('.algorithm-btn').forEach(btn => {
                    btn.addEventListener('click', () => this.selectAlgorithm(btn.dataset.algorithm));
                });

                // Controls
                this.arraySizeInput.addEventListener('input', (e) => {
                    this.arraySizeValue.textContent = e.target.value;
                    this.generateArray();
                });

                this.speedInput.addEventListener('input', (e) => {
                    this.speedValue.textContent = e.target.value;
                    this.speed = parseInt(e.target.value);
                });

                this.generateBtn.addEventListener('click', () => this.generateArray());
                this.startBtn.addEventListener('click', () => this.startSorting());
                this.resetBtn.addEventListener('click', () => this.reset());
            }

            selectAlgorithm(algorithm) {
                this.currentAlgorithm = algorithm;
                
                // Update button states
                document.querySelectorAll('.algorithm-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelector(`[data-algorithm="${algorithm}"]`).classList.add('active');
                
                // Update algorithm info
                this.updateAlgorithmInfo(algorithm);
                
                // Update code blocks based on algorithm
                this.updateCodeBlocks(algorithm);
            }

            updateAlgorithmInfo(algorithm) {
                const info = {
                    bubble: {
                        name: 'Bubble Sort',
                        description: 'Bubble Sort repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order. Time Complexity: O(n²), Space Complexity: O(1)'
                    },
                    selection: {
                        name: 'Selection Sort',
                        description: 'Selection Sort finds the minimum element and swaps it with the first element, then repeats for the remaining elements. Time Complexity: O(n²), Space Complexity: O(1)'
                    },
                    insertion: {
                        name: 'Insertion Sort',
                        description: 'Insertion Sort builds the final sorted array one item at a time by inserting each element into its correct position. Time Complexity: O(n²), Space Complexity: O(1)'
                    },
                    merge: {
                        name: 'Merge Sort',
                        description: 'Merge Sort divides the array into two halves, sorts them recursively, and then merges the sorted halves. Time Complexity: O(n log n), Space Complexity: O(n)'
                    },
                    quick: {
                        name: 'Quick Sort',
                        description: 'Quick Sort picks a pivot element and partitions the array around the pivot, then recursively sorts the sub-arrays. Time Complexity: O(n log n) average, O(n²) worst case, Space Complexity: O(log n)'
                    },
                    heap: {
                        name: 'Heap Sort',
                        description: 'Heap Sort builds a max heap and repeatedly extracts the maximum element to build the sorted array. Time Complexity: O(n log n), Space Complexity: O(1)'
                    }
                };

                const algorithmInfo = info[algorithm];
                this.algorithmInfo.innerHTML = `
                    <h4>${algorithmInfo.name}</h4>
                    <p>${algorithmInfo.description}</p>
                `;
            }

            generateArray() {
                const size = parseInt(this.arraySizeInput.value);
                this.array = [];
                
                for (let i = 0; i < size; i++) {
                    this.array.push(Math.floor(Math.random() * 100) + 1);
                }
                
                this.originalArray = [...this.array];
                this.renderArray();
                this.resetStats();
            }

            renderArray() {
                const data = this.array.map((value, index) => ({ value, index }));
                const barWidth = (this.width - this.margin.left - this.margin.right) / this.array.length;
                const maxValue = Math.max(...this.array);
                
                // Clear previous content
                this.svg.selectAll('*').remove();
                
                // Create bars
                const bars = this.svg.selectAll('.bar')
                    .data(data)
                    .join('rect')
                    .attr('class', 'bar')
                    .attr('x', (d, i) => this.margin.left + i * barWidth)
                    .attr('y', d => this.height - this.margin.bottom - (d.value / maxValue) * (this.height - this.margin.top - this.margin.bottom))
                    .attr('width', barWidth - 2)
                    .attr('height', d => (d.value / maxValue) * (this.height - this.margin.top - this.margin.bottom));

                // Create labels
                const labels = this.svg.selectAll('.bar-label')
                    .data(data)
                    .join('text')
                    .attr('class', 'bar-label')
                    .attr('x', (d, i) => this.margin.left + i * barWidth + barWidth / 2)
                    .attr('y', d => this.height - this.margin.bottom - (d.value / maxValue) * (this.height - this.margin.top - this.margin.bottom) - 5)
                    .text(d => d.value);
            }

            async startSorting() {
                if (this.isRunning) return;
                
                this.isRunning = true;
                this.startBtn.disabled = true;
                this.resetStats();
                this.startTime = performance.now();

                // Reset array to original state
                this.array = [...this.originalArray];
                this.renderArray();

                try {
                    switch (this.currentAlgorithm) {
                        case 'bubble':
                            await this.bubbleSort();
                            break;
                        case 'selection':
                            await this.selectionSort();
                            break;
                        case 'insertion':
                            await this.insertionSort();
                            break;
                        case 'merge':
                            await this.mergeSort();
                            break;
                        case 'quick':
                            await this.quickSort();
                            break;
                        case 'heap':
                            await this.heapSort();
                            break;
                    }
                } finally {
                    this.isRunning = false;
                    this.startBtn.disabled = false;
                    this.updateDuration();
                }
            }

            async bubbleSort() {
                const n = this.array.length;
                for (let i = 0; i < n - 1; i++) {
                    for (let j = 0; j < n - i - 1; j++) {
                        this.comparisons++;
                        this.updateStats();
                        
                        // Highlight comparing elements
                        this.highlightBars([j, j + 1], 'comparing');
                        await this.delay();
                        
                        if (this.array[j] > this.array[j + 1]) {
                            // Swap elements
                            [this.array[j], this.array[j + 1]] = [this.array[j + 1], this.array[j]];
                            this.swaps++;
                            this.updateStats();
                            
                            this.highlightBars([j, j + 1], 'swapping');
                            await this.delay();
                        }
                        
                        this.renderArray();
                    }
                }
            }

            async selectionSort() {
                const n = this.array.length;
                for (let i = 0; i < n - 1; i++) {
                    let minIdx = i;
                    
                    for (let j = i + 1; j < n; j++) {
                        this.comparisons++;
                        this.updateStats();
                        
                        this.highlightBars([minIdx, j], 'comparing');
                        await this.delay();
                        
                        if (this.array[j] < this.array[minIdx]) {
                            minIdx = j;
                        }
                    }
                    
                    if (minIdx !== i) {
                        [this.array[i], this.array[minIdx]] = [this.array[minIdx], this.array[i]];
                        this.swaps++;
                        this.updateStats();
                        
                        this.highlightBars([i, minIdx], 'swapping');
                        await this.delay();
                    }
                    
                    this.renderArray();
                }
            }

            async insertionSort() {
                const n = this.array.length;
                for (let i = 1; i < n; i++) {
                    let key = this.array[i];
                    let j = i - 1;
                    
                    while (j >= 0 && this.array[j] > key) {
                        this.comparisons++;
                        this.updateStats();
                        
                        this.highlightBars([j, j + 1], 'comparing');
                        await this.delay();
                        
                        this.array[j + 1] = this.array[j];
                        this.swaps++;
                        this.updateStats();
                        
                        this.highlightBars([j, j + 1], 'swapping');
                        await this.delay();
                        
                        j--;
                    }
                    
                    this.array[j + 1] = key;
                    this.renderArray();
                }
            }

            async mergeSort() {
                await this.mergeSortHelper(0, this.array.length - 1);
            }

            async mergeSortHelper(left, right) {
                if (left < right) {
                    const mid = Math.floor((left + right) / 2);
                    
                    await this.mergeSortHelper(left, mid);
                    await this.mergeSortHelper(mid + 1, right);
                    await this.merge(left, mid, right);
                }
            }

            async merge(left, mid, right) {
                const leftArr = this.array.slice(left, mid + 1);
                const rightArr = this.array.slice(mid + 1, right + 1);
                
                let i = 0, j = 0, k = left;
                
                while (i < leftArr.length && j < rightArr.length) {
                    this.comparisons++;
                    this.updateStats();
                    
                    this.highlightBars([k], 'comparing');
                    await this.delay();
                    
                    if (leftArr[i] <= rightArr[j]) {
                        this.array[k] = leftArr[i];
                        i++;
                    } else {
                        this.array[k] = rightArr[j];
                        j++;
                    }
                    
                    this.swaps++;
                    this.updateStats();
                    this.renderArray();
                    k++;
                }
                
                while (i < leftArr.length) {
                    this.array[k] = leftArr[i];
                    i++;
                    k++;
                    this.renderArray();
                }
                
                while (j < rightArr.length) {
                    this.array[k] = rightArr[j];
                    j++;
                    k++;
                    this.renderArray();
                }
            }

            async quickSort() {
                await this.quickSortHelper(0, this.array.length - 1);
            }

            async quickSortHelper(low, high) {
                if (low < high) {
                    const pivotIndex = await this.partition(low, high);
                    await this.quickSortHelper(low, pivotIndex - 1);
                    await this.quickSortHelper(pivotIndex + 1, high);
                }
            }

            async partition(low, high) {
                const pivot = this.array[high];
                let i = low - 1;
                
                this.highlightBars([high], 'pivot');
                await this.delay();
                
                for (let j = low; j < high; j++) {
                    this.comparisons++;
                    this.updateStats();
                    
                    this.highlightBars([j, high], 'comparing');
                    await this.delay();
                    
                    if (this.array[j] < pivot) {
                        i++;
                        [this.array[i], this.array[j]] = [this.array[j], this.array[i]];
                        this.swaps++;
                        this.updateStats();
                        
                        this.highlightBars([i, j], 'swapping');
                        await this.delay();
                    }
                }
                
                [this.array[i + 1], this.array[high]] = [this.array[high], this.array[i + 1]];
                this.swaps++;
                this.updateStats();
                
                this.highlightBars([i + 1, high], 'swapping');
                await this.delay();
                this.renderArray();
                
                return i + 1;
            }

            async heapSort() {
                const n = this.array.length;
                
                // Build max heap
                for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
                    await this.heapify(n, i);
                }
                
                // Extract elements from heap one by one
                for (let i = n - 1; i > 0; i--) {
                    [this.array[0], this.array[i]] = [this.array[i], this.array[0]];
                    this.swaps++;
                    this.updateStats();
                    
                    this.highlightBars([0, i], 'swapping');
                    await this.delay();
                    this.renderArray();
                    
                    await this.heapify(i, 0);
                }
            }

            async heapify(n, i) {
                let largest = i;
                const left = 2 * i + 1;
                const right = 2 * i + 2;
                
                if (left < n) {
                    this.comparisons++;
                    this.updateStats();
                    
                    this.highlightBars([largest, left], 'comparing');
                    await this.delay();
                    
                    if (this.array[left] > this.array[largest]) {
                        largest = left;
                    }
                }
                
                if (right < n) {
                    this.comparisons++;
                    this.updateStats();
                    
                    this.highlightBars([largest, right], 'comparing');
                    await this.delay();
                    
                    if (this.array[right] > this.array[largest]) {
                        largest = right;
                    }
                }
                
                if (largest !== i) {
                    [this.array[i], this.array[largest]] = [this.array[largest], this.array[i]];
                    this.swaps++;
                    this.updateStats();
                    
                    this.highlightBars([i, largest], 'swapping');
                    await this.delay();
                    this.renderArray();
                    
                    await this.heapify(n, largest);
                }
            }

            highlightBars(indices, state) {
                this.svg.selectAll('.bar')
                    .filter((d, i) => indices.includes(i))
                    .classed('comparing', state === 'comparing')
                    .classed('swapping', state === 'swapping')
                    .classed('pivot', state === 'pivot');
            }

            reset() {
                this.array = [...this.originalArray];
                this.renderArray();
                this.resetStats();
            }

            resetStats() {
                this.comparisons = 0;
                this.swaps = 0;
                this.startTime = 0;
                this.updateStats();
            }

            updateStats() {
                this.comparisonsEl.textContent = this.comparisons;
                this.swapsEl.textContent = this.swaps;
            }

            updateDuration() {
                const duration = Math.round(performance.now() - this.startTime);
                this.timeEl.textContent = `${duration}ms`;
            }

            delay() {
                const delayTime = Math.max(50, 500 - (this.speed * 50));
                return new Promise(resolve => setTimeout(resolve, delayTime));
            }

            initializeCodeBlocks() {
                // Go code for sorting algorithms
                const goCode = `func BubbleSort(arr []int) {
    n := len(arr)
    for i := 0; i < n-1; i++ {
        for j := 0; j < n-i-1; j++ {
            if arr[j] > arr[j+1] {
                arr[j], arr[j+1] = arr[j+1], arr[j]
            }
        }
    }
}

func QuickSort(arr []int) {
    quickSortRecursive(arr, 0, len(arr)-1)
}

func quickSortRecursive(arr []int, low, high int) {
    if low < high {
        pi := partition(arr, low, high)
        quickSortRecursive(arr, low, pi-1)
        quickSortRecursive(arr, pi+1, high)
    }
}

func partition(arr []int, low, high int) int {
    pivot := arr[high]
    i := low - 1
    
    for j := low; j < high; j++ {
        if arr[j] < pivot {
            i++
            arr[i], arr[j] = arr[j], arr[i]
        }
    }
    arr[i+1], arr[high] = arr[high], arr[i+1]
    return i + 1
}`;

                // Java code for sorting algorithms
                const javaCode = `public static void bubbleSort(int[] arr) {
    int n = arr.length;
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

public static void quickSort(int[] arr) {
    quickSortRecursive(arr, 0, arr.length - 1);
}

private static void quickSortRecursive(int[] arr, int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSortRecursive(arr, low, pi - 1);
        quickSortRecursive(arr, pi + 1, high);
    }
}

private static int partition(int[] arr, int low, int high) {
    int pivot = arr[high];
    int i = (low - 1);
    
    for (int j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
    int temp = arr[i + 1];
    arr[i + 1] = arr[high];
    arr[high] = temp;
    return i + 1;
}`;

                // Create code blocks
                const goCodeBlock = this.codeSync.createCodeBlock(goCode, 'go');
                const javaCodeBlock = this.codeSync.createCodeBlock(javaCode, 'java');
                
                document.getElementById('goCodeBlock').appendChild(goCodeBlock);
                document.getElementById('javaCodeBlock').appendChild(javaCodeBlock);

                // Register code blocks
                this.codeSync.registerCodeBlock('go', goCodeBlock, [
                    { line: 1, description: 'Bubble Sort function definition' },
                    { line: 2, description: 'Get array length' },
                    { line: 3, description: 'Outer loop for passes' },
                    { line: 4, description: 'Inner loop for comparisons' },
                    { line: 5, description: 'Compare adjacent elements' },
                    { line: 6, description: 'Swap if out of order' },
                    { line: 12, description: 'Quick Sort function definition' },
                    { line: 13, description: 'Call recursive function' },
                    { line: 16, description: 'Recursive Quick Sort function' },
                    { line: 17, description: 'Check if low < high' },
                    { line: 18, description: 'Partition the array' },
                    { line: 19, description: 'Sort left partition' },
                    { line: 20, description: 'Sort right partition' },
                    { line: 24, description: 'Partition function definition' },
                    { line: 25, description: 'Choose pivot element' },
                    { line: 26, description: 'Initialize partition index' },
                    { line: 28, description: 'Loop through array' },
                    { line: 29, description: 'Compare with pivot' },
                    { line: 30, description: 'Increment partition index' },
                    { line: 31, description: 'Swap elements' },
                    { line: 35, description: 'Place pivot in correct position' },
                    { line: 36, description: 'Return partition index' }
                ]);

                this.codeSync.registerCodeBlock('java', javaCodeBlock, [
                    { line: 1, description: 'Bubble Sort method definition' },
                    { line: 2, description: 'Get array length' },
                    { line: 3, description: 'Outer loop for passes' },
                    { line: 4, description: 'Inner loop for comparisons' },
                    { line: 5, description: 'Compare adjacent elements' },
                    { line: 6, description: 'Swap if out of order' },
                    { line: 12, description: 'Quick Sort method definition' },
                    { line: 13, description: 'Call recursive method' },
                    { line: 16, description: 'Recursive Quick Sort method' },
                    { line: 17, description: 'Check if low < high' },
                    { line: 18, description: 'Partition the array' },
                    { line: 19, description: 'Sort left partition' },
                    { line: 20, description: 'Sort right partition' },
                    { line: 24, description: 'Partition method definition' },
                    { line: 25, description: 'Choose pivot element' },
                    { line: 26, description: 'Initialize partition index' },
                    { line: 28, description: 'Loop through array' },
                    { line: 29, description: 'Compare with pivot' },
                    { line: 30, description: 'Increment partition index' },
                    { line: 31, description: 'Swap elements' },
                    { line: 35, description: 'Place pivot in correct position' },
                    { line: 36, description: 'Return partition index' }
                ]);
            }

            setupCodeEventListeners() {
                // Listen for execution completion
                document.addEventListener('codeExecutionComplete', (event) => {
                    this.onCodeExecutionComplete(event.detail);
                });
            }

            onCodeExecutionComplete(detail) {
                const metrics = detail.metrics;
                document.getElementById('totalComparisons').textContent = metrics.comparisons;
                document.getElementById('totalSwaps').textContent = metrics.swaps;
                document.getElementById('totalOperations').textContent = metrics.operations;
                document.getElementById('totalDuration').textContent = Math.round(metrics.duration);
                
                // Update complexity analysis based on current algorithm
                this.updateComplexityAnalysis();
                
                this.showMessage('Code execution completed successfully!', 'success');
            }

            updateComplexityAnalysis() {
                const complexities = {
                    bubble: { time: 'O(n²)', space: 'O(1)' },
                    selection: { time: 'O(n²)', space: 'O(1)' },
                    insertion: { time: 'O(n²)', space: 'O(1)' },
                    merge: { time: 'O(n log n)', space: 'O(n)' },
                    quick: { time: 'O(n log n) avg, O(n²) worst', space: 'O(log n)' },
                    heap: { time: 'O(n log n)', space: 'O(1)' }
                };
                
                const complexity = complexities[this.currentAlgorithm];
                document.getElementById('timeComplexity').textContent = complexity.time;
                document.getElementById('spaceComplexity').textContent = complexity.space;
            }

            async startSortingWithCodeSync() {
                if (this.isRunning) return;
                
                this.isRunning = true;
                this.startBtn.disabled = true;
                this.resetStats();
                this.startTime = performance.now();

                // Reset array to original state
                this.array = [...this.originalArray];
                this.renderArray();

                try {
                    // Define execution steps for code synchronization
                    const executionSteps = this.generateExecutionSteps();
                    
                    // Start code execution synchronization
                    await this.codeSync.startExecution(`${this.currentAlgorithm}Sort`, executionSteps);
                    
                    // Execute the actual sorting algorithm
                    switch (this.currentAlgorithm) {
                        case 'bubble':
                            await this.bubbleSort();
                            break;
                        case 'selection':
                            await this.selectionSort();
                            break;
                        case 'insertion':
                            await this.insertionSort();
                            break;
                        case 'merge':
                            await this.mergeSort();
                            break;
                        case 'quick':
                            await this.quickSort();
                            break;
                        case 'heap':
                            await this.heapSort();
                            break;
                    }
                } finally {
                    this.isRunning = false;
                    this.startBtn.disabled = false;
                    this.updateDuration();
                }
            }

            generateExecutionSteps() {
                const steps = [];
                
                switch (this.currentAlgorithm) {
                    case 'bubble':
                        steps.push(
                            {
                                id: 'bubble_start',
                                codeBlocks: { go: [1, 2], java: [1, 2] },
                                type: 'executing',
                                description: 'Starting Bubble Sort',
                                metrics: { operations: 1 }
                            },
                            {
                                id: 'bubble_outer_loop',
                                codeBlocks: { go: [3], java: [3] },
                                type: 'executing',
                                description: 'Outer loop for passes',
                                metrics: { operations: 1 }
                            },
                            {
                                id: 'bubble_inner_loop',
                                codeBlocks: { go: [4], java: [4] },
                                type: 'executing',
                                description: 'Inner loop for comparisons',
                                metrics: { operations: 1 }
                            },
                            {
                                id: 'bubble_compare',
                                codeBlocks: { go: [5], java: [5] },
                                type: 'comparing',
                                description: 'Compare adjacent elements',
                                metrics: { comparisons: 1 }
                            },
                            {
                                id: 'bubble_swap',
                                codeBlocks: { go: [6], java: [6] },
                                type: 'swapping',
                                description: 'Swap if out of order',
                                metrics: { swaps: 1 }
                            }
                        );
                        break;
                        
                    case 'quick':
                        steps.push(
                            {
                                id: 'quick_start',
                                codeBlocks: { go: [12, 13], java: [12, 13] },
                                type: 'executing',
                                description: 'Starting Quick Sort',
                                metrics: { operations: 1 }
                            },
                            {
                                id: 'quick_recursive',
                                codeBlocks: { go: [16, 17], java: [16, 17] },
                                type: 'executing',
                                description: 'Recursive Quick Sort call',
                                metrics: { operations: 1 }
                            },
                            {
                                id: 'quick_partition',
                                codeBlocks: { go: [18], java: [18] },
                                type: 'executing',
                                description: 'Partition the array',
                                metrics: { operations: 1 }
                            },
                            {
                                id: 'quick_compare',
                                codeBlocks: { go: [29], java: [29] },
                                type: 'comparing',
                                description: 'Compare with pivot',
                                metrics: { comparisons: 1 }
                            },
                            {
                                id: 'quick_swap',
                                codeBlocks: { go: [31], java: [31] },
                                type: 'swapping',
                                description: 'Swap elements',
                                metrics: { swaps: 1 }
                            }
                        );
                        break;
                }
                
                return steps;
            }

            updateCodeBlocks(algorithm) {
                const goCodeBlock = document.getElementById('goCodeBlock');
                const javaCodeBlock = document.getElementById('javaCodeBlock');
                
                if (!goCodeBlock || !javaCodeBlock) return;
                
                // Clear existing code
                goCodeBlock.innerHTML = '';
                javaCodeBlock.innerHTML = '';
                
                let goCode, javaCode;
                
                switch (algorithm) {
                    case 'bubble':
                        goCode = `func BubbleSort(arr []int) {
    n := len(arr)
    for i := 0; i < n-1; i++ {
        for j := 0; j < n-i-1; j++ {
            if arr[j] > arr[j+1] {
                arr[j], arr[j+1] = arr[j+1], arr[j]
            }
        }
    }
}`;
                        
                        javaCode = `public static void bubbleSort(int[] arr) {
    int n = arr.length;
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}`;
                        break;
                        
                    case 'quick':
                        goCode = `func QuickSort(arr []int) {
    quickSortRecursive(arr, 0, len(arr)-1)
}

func quickSortRecursive(arr []int, low, high int) {
    if low < high {
        pi := partition(arr, low, high)
        quickSortRecursive(arr, low, pi-1)
        quickSortRecursive(arr, pi+1, high)
    }
}

func partition(arr []int, low, high int) int {
    pivot := arr[high]
    i := low - 1
    
    for j := low; j < high; j++ {
        if arr[j] < pivot {
            i++
            arr[i], arr[j] = arr[j], arr[i]
        }
    }
    arr[i+1], arr[high] = arr[high], arr[i+1]
    return i + 1
}`;
                        
                        javaCode = `public static void quickSort(int[] arr) {
    quickSortRecursive(arr, 0, arr.length - 1);
}

private static void quickSortRecursive(int[] arr, int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSortRecursive(arr, low, pi - 1);
        quickSortRecursive(arr, pi + 1, high);
    }
}

private static int partition(int[] arr, int low, int high) {
    int pivot = arr[high];
    int i = (low - 1);
    
    for (int j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
    int temp = arr[i + 1];
    arr[i + 1] = arr[high];
    arr[high] = temp;
    return i + 1;
}`;
                        break;
                        
                    case 'merge':
                        goCode = `func MergeSort(arr []int) {
    if len(arr) < 2 {
        return
    }
    mid := len(arr) / 2
    left := make([]int, mid)
    right := make([]int, len(arr)-mid)
    copy(left, arr[:mid])
    copy(right, arr[mid:])
    
    MergeSort(left)
    MergeSort(right)
    merge(arr, left, right)
}

func merge(arr, left, right []int) {
    i, j, k := 0, 0, 0
    for i < len(left) && j < len(right) {
        if left[i] <= right[j] {
            arr[k] = left[i]
            i++
        } else {
            arr[k] = right[j]
            j++
        }
        k++
    }
    for i < len(left) {
        arr[k] = left[i]
        i++
        k++
    }
    for j < len(right) {
        arr[k] = right[j]
        j++
        k++
    }
}`;
                        
                        javaCode = `public static void mergeSort(int[] arr) {
    if (arr.length < 2) {
        return;
    }
    int mid = arr.length / 2;
    int[] left = new int[mid];
    int[] right = new int[arr.length - mid];
    
    System.arraycopy(arr, 0, left, 0, mid);
    System.arraycopy(arr, mid, right, 0, arr.length - mid);
    
    mergeSort(left);
    mergeSort(right);
    merge(arr, left, right);
}

private static void merge(int[] arr, int[] left, int[] right) {
    int i = 0, j = 0, k = 0;
    while (i < left.length && j < right.length) {
        if (left[i] <= right[j]) {
            arr[k] = left[i];
            i++;
        } else {
            arr[k] = right[j];
            j++;
        }
        k++;
    }
    while (i < left.length) {
        arr[k] = left[i];
        i++;
        k++;
    }
    while (j < right.length) {
        arr[k] = right[j];
        j++;
        k++;
    }
}`;
                        break;
                        
                    default:
                        goCode = `// Select an algorithm to see its implementation`;
                        javaCode = `// Select an algorithm to see its implementation`;
                }
                
                // Create new code blocks
                const newGoCodeBlock = this.codeSync.createCodeBlock(goCode, 'go');
                const newJavaCodeBlock = this.codeSync.createCodeBlock(javaCode, 'java');
                
                goCodeBlock.appendChild(newGoCodeBlock);
                javaCodeBlock.appendChild(newJavaCodeBlock);
                
                // Re-register code blocks
                this.codeSync.registerCodeBlock('go', newGoCodeBlock, this.getStepDefinitions(algorithm));
                this.codeSync.registerCodeBlock('java', newJavaCodeBlock, this.getStepDefinitions(algorithm));
            }

            getStepDefinitions(algorithm) {
                const stepDefinitions = {
                    bubble: [
                        { line: 1, description: 'Bubble Sort function definition' },
                        { line: 2, description: 'Get array length' },
                        { line: 3, description: 'Outer loop for passes' },
                        { line: 4, description: 'Inner loop for comparisons' },
                        { line: 5, description: 'Compare adjacent elements' },
                        { line: 6, description: 'Swap if out of order' }
                    ],
                    quick: [
                        { line: 1, description: 'Quick Sort function definition' },
                        { line: 2, description: 'Call recursive function' },
                        { line: 5, description: 'Recursive Quick Sort function' },
                        { line: 6, description: 'Check if low < high' },
                        { line: 7, description: 'Partition the array' },
                        { line: 8, description: 'Sort left partition' },
                        { line: 9, description: 'Sort right partition' },
                        { line: 13, description: 'Partition function definition' },
                        { line: 14, description: 'Choose pivot element' },
                        { line: 15, description: 'Initialize partition index' },
                        { line: 17, description: 'Loop through array' },
                        { line: 18, description: 'Compare with pivot' },
                        { line: 19, description: 'Increment partition index' },
                        { line: 20, description: 'Swap elements' },
                        { line: 23, description: 'Place pivot in correct position' },
                        { line: 24, description: 'Return partition index' }
                    ],
                    merge: [
                        { line: 1, description: 'Merge Sort function definition' },
                        { line: 2, description: 'Check if array has less than 2 elements' },
                        { line: 3, description: 'Return if base case' },
                        { line: 4, description: 'Calculate middle index' },
                        { line: 5, description: 'Create left array' },
                        { line: 6, description: 'Create right array' },
                        { line: 7, description: 'Copy left half' },
                        { line: 8, description: 'Copy right half' },
                        { line: 10, description: 'Recursively sort left half' },
                        { line: 11, description: 'Recursively sort right half' },
                        { line: 12, description: 'Merge sorted halves' }
                    ]
                };
                
                return stepDefinitions[algorithm] || [];
            }
        }

        // Global functions for code execution controls
        function startCodeExecution() {
            if (window.sortingVisualizer) {
                window.sortingVisualizer.startSortingWithCodeSync();
            }
        }

        function pauseCodeExecution() {
            if (window.sortingVisualizer && window.sortingVisualizer.codeSync) {
                window.sortingVisualizer.codeSync.pauseExecution();
            }
        }

        function stopCodeExecution() {
            if (window.sortingVisualizer && window.sortingVisualizer.codeSync) {
                window.sortingVisualizer.codeSync.stopExecution();
            }
        }

        function updateExecutionSpeed() {
            const speed = document.getElementById('executionSpeed').value;
            if (window.sortingVisualizer && window.sortingVisualizer.codeSync) {
                window.sortingVisualizer.codeSync.setExecutionSpeed(parseInt(speed));
            }
        }

        // Initialize the visualizer when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.sortingVisualizer = new SortingVisualizer();
        });
    </script>
</body>
</html>
