<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithms - PrepGuides.dev</title>
    <meta name="description" content="Interactive visualization of sorting algorithms including Bubble Sort, Selection Sort, Insertion Sort, Merge Sort, Quick Sort, and Heap Sort">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #6366f1;
            --secondary: #8b5cf6;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --dark: #1f2937;
            --light: #f3f4f6;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .main-container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 24px;
            overflow: hidden;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
        }

        header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white;
            padding: 40px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .back-button {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            text-decoration: none;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .back-button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        h1 {
            font-size: 3rem;
            font-weight: 800;
            margin-bottom: 1rem;
            position: relative;
            z-index: 1;
        }

        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            position: relative;
            z-index: 1;
        }

        .content {
            padding: 40px;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 30px;
            align-items: center;
            justify-content: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: center;
        }

        .control-group label {
            font-weight: 600;
            color: var(--dark);
            font-size: 0.9rem;
        }

        select, input, button {
            padding: 12px 16px;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            font-size: 1rem;
            transition: all 0.3s ease;
            background: white;
        }

        select:focus, input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }

        button {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
            min-width: 120px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(99, 102, 241, 0.3);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .visualization {
            background: #f8fafc;
            border-radius: 16px;
            padding: 30px;
            margin-bottom: 30px;
            border: 2px solid #e2e8f0;
        }

        .array-container {
            display: flex;
            justify-content: center;
            align-items: end;
            height: 300px;
            gap: 4px;
            margin-bottom: 20px;
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .bar {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            border-radius: 4px 4px 0 0;
            transition: all 0.3s ease;
            min-width: 8px;
            position: relative;
            display: flex;
            align-items: end;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 0.8rem;
            padding: 4px 0;
        }

        .bar.comparing {
            background: var(--warning);
            transform: scale(1.05);
        }

        .bar.swapping {
            background: var(--danger);
            transform: scale(1.1);
        }

        .bar.sorted {
            background: var(--success);
        }

        .bar.pivot {
            background: var(--secondary);
            box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.3);
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            border: 1px solid #e5e7eb;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 800;
            color: var(--primary);
            margin-bottom: 8px;
        }

        .stat-label {
            color: #6b7280;
            font-weight: 500;
        }

        .algorithm-info {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            border: 1px solid #e5e7eb;
        }

        .algorithm-info h3 {
            color: var(--dark);
            margin-bottom: 15px;
            font-size: 1.5rem;
        }

        .complexity {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .complexity-item {
            text-align: center;
            padding: 15px;
            background: #f8fafc;
            border-radius: 8px;
        }

        .complexity-item h4 {
            color: var(--dark);
            margin-bottom: 5px;
            font-size: 0.9rem;
        }

        .complexity-item p {
            color: var(--primary);
            font-weight: 700;
            font-size: 1.1rem;
        }

        .description {
            color: #6b7280;
            line-height: 1.6;
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: stretch;
            }

            .control-group {
                align-items: stretch;
            }

            h1 {
                font-size: 2rem;
            }

            .array-container {
                height: 200px;
                gap: 2px;
            }

            .bar {
                min-width: 6px;
                font-size: 0.7rem;
            }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <header>
            <a href="index.html" class="back-button">← Back to Home</a>
            <h1>Sorting Algorithms Visualizer</h1>
            <p class="subtitle">Interactive visualization of sorting algorithms with real-time performance metrics</p>
        </header>

        <div class="content">
            <div class="controls">
                <div class="control-group">
                    <label for="algorithm">Algorithm</label>
                    <select id="algorithm">
                        <option value="bubble">Bubble Sort</option>
                        <option value="selection">Selection Sort</option>
                        <option value="insertion">Insertion Sort</option>
                        <option value="merge">Merge Sort</option>
                        <option value="quick">Quick Sort</option>
                        <option value="heap">Heap Sort</option>
                    </select>
                </div>

                <div class="control-group">
                    <label for="size">Array Size</label>
                    <input type="range" id="size" min="10" max="100" value="50">
                    <span id="sizeValue">50</span>
                </div>

                <div class="control-group">
                    <label for="speed">Speed</label>
                    <input type="range" id="speed" min="1" max="10" value="5">
                    <span id="speedValue">5</span>
                </div>

                <div class="control-group">
                    <button id="generate">Generate Array</button>
                    <button id="start">Start Sorting</button>
                </div>
            </div>

            <div class="visualization">
                <div class="array-container" id="arrayContainer"></div>
            </div>

            <div class="stats">
                <div class="stat-card">
                    <div class="stat-value" id="comparisons">0</div>
                    <div class="stat-label">Comparisons</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="swaps">0</div>
                    <div class="stat-label">Swaps</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="time">0ms</div>
                    <div class="stat-label">Time</div>
                </div>
            </div>

            <div class="algorithm-info">
                <h3 id="algorithmName">Bubble Sort</h3>
                <div class="complexity">
                    <div class="complexity-item">
                        <h4>Time Complexity</h4>
                        <p id="timeComplexity">O(n²)</p>
                    </div>
                    <div class="complexity-item">
                        <h4>Space Complexity</h4>
                        <p id="spaceComplexity">O(1)</p>
                    </div>
                    <div class="complexity-item">
                        <h4>Stable</h4>
                        <p id="stability">Yes</p>
                    </div>
                </div>
                <div class="description" id="description">
                    Bubble Sort repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order. The pass through the list is repeated until the list is sorted.
                </div>
            </div>
        </div>
    </div>

    <script>
        class SortingVisualizer {
            constructor() {
                this.array = [];
                this.isRunning = false;
                this.comparisons = 0;
                this.swaps = 0;
                this.startTime = 0;
                
                this.initializeElements();
                this.setupEventListeners();
                this.generateArray();
                this.updateAlgorithmInfo();
            }

            initializeElements() {
                this.arrayContainer = document.getElementById('arrayContainer');
                this.algorithmSelect = document.getElementById('algorithm');
                this.sizeSlider = document.getElementById('size');
                this.speedSlider = document.getElementById('speed');
                this.generateBtn = document.getElementById('generate');
                this.startBtn = document.getElementById('start');
                this.sizeValue = document.getElementById('sizeValue');
                this.speedValue = document.getElementById('speedValue');
                this.comparisonsEl = document.getElementById('comparisons');
                this.swapsEl = document.getElementById('swaps');
                this.timeEl = document.getElementById('time');
                this.algorithmName = document.getElementById('algorithmName');
                this.timeComplexity = document.getElementById('timeComplexity');
                this.spaceComplexity = document.getElementById('spaceComplexity');
                this.stability = document.getElementById('stability');
                this.description = document.getElementById('description');
            }

            setupEventListeners() {
                this.generateBtn.addEventListener('click', () => this.generateArray());
                this.startBtn.addEventListener('click', () => this.startSorting());
                this.algorithmSelect.addEventListener('change', () => this.updateAlgorithmInfo());
                this.sizeSlider.addEventListener('input', (e) => {
                    this.sizeValue.textContent = e.target.value;
                });
                this.speedSlider.addEventListener('input', (e) => {
                    this.speedValue.textContent = e.target.value;
                });
            }

            generateArray() {
                if (this.isRunning) return;
                
                const size = parseInt(this.sizeSlider.value);
                this.array = Array.from({ length: size }, () => Math.floor(Math.random() * 100) + 1);
                this.renderArray();
                this.resetStats();
            }

            renderArray() {
                this.arrayContainer.innerHTML = '';
                const maxValue = Math.max(...this.array);
                
                this.array.forEach((value, index) => {
                    const bar = document.createElement('div');
                    bar.className = 'bar';
                    bar.style.height = `${(value / maxValue) * 100}%`;
                    bar.textContent = value;
                    bar.dataset.index = index;
                    this.arrayContainer.appendChild(bar);
                });
            }

            async startSorting() {
                if (this.isRunning) return;
                
                this.isRunning = true;
                this.startBtn.disabled = true;
                this.generateBtn.disabled = true;
                this.resetStats();
                this.startTime = performance.now();

                const algorithm = this.algorithmSelect.value;
                
                try {
                    switch (algorithm) {
                        case 'bubble':
                            await this.bubbleSort();
                            break;
                        case 'selection':
                            await this.selectionSort();
                            break;
                        case 'insertion':
                            await this.insertionSort();
                            break;
                        case 'merge':
                            await this.mergeSort();
                            break;
                        case 'quick':
                            await this.quickSort();
                            break;
                        case 'heap':
                            await this.heapSort();
                            break;
                    }
                } finally {
                    this.isRunning = false;
                    this.startBtn.disabled = false;
                    this.generateBtn.disabled = false;
                    this.markAllAsSorted();
                }
            }

            async sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            async highlightBars(i, j, type = 'comparing') {
                const bars = this.arrayContainer.children;
                if (bars[i]) bars[i].classList.add(type);
                if (bars[j]) bars[j].classList.add(type);
                
                await this.sleep(1000 / this.speedSlider.value * 10);
                
                if (bars[i]) bars[i].classList.remove(type);
                if (bars[j]) bars[j].classList.remove(type);
            }

            async swapBars(i, j) {
                const bars = this.arrayContainer.children;
                if (bars[i]) bars[i].classList.add('swapping');
                if (bars[j]) bars[j].classList.add('swapping');
                
                await this.sleep(1000 / this.speedSlider.value * 10);
                
                [this.array[i], this.array[j]] = [this.array[j], this.array[i]];
                this.renderArray();
                this.swaps++;
                this.swapsEl.textContent = this.swaps;
                
                if (bars[i]) bars[i].classList.remove('swapping');
                if (bars[j]) bars[j].classList.remove('swapping');
            }

            markAllAsSorted() {
                const bars = this.arrayContainer.children;
                Array.from(bars).forEach(bar => bar.classList.add('sorted'));
            }

            resetStats() {
                this.comparisons = 0;
                this.swaps = 0;
                this.comparisonsEl.textContent = '0';
                this.swapsEl.textContent = '0';
                this.timeEl.textContent = '0ms';
            }

            updateStats() {
                const currentTime = performance.now();
                const elapsed = Math.round(currentTime - this.startTime);
                this.timeEl.textContent = `${elapsed}ms`;
            }

            // Bubble Sort
            async bubbleSort() {
                const n = this.array.length;
                for (let i = 0; i < n - 1; i++) {
                    for (let j = 0; j < n - i - 1; j++) {
                        this.comparisons++;
                        this.comparisonsEl.textContent = this.comparisons;
                        this.updateStats();
                        
                        await this.highlightBars(j, j + 1);
                        
                        if (this.array[j] > this.array[j + 1]) {
                            await this.swapBars(j, j + 1);
                        }
                    }
                }
            }

            // Selection Sort
            async selectionSort() {
                const n = this.array.length;
                for (let i = 0; i < n - 1; i++) {
                    let minIdx = i;
                    for (let j = i + 1; j < n; j++) {
                        this.comparisons++;
                        this.comparisonsEl.textContent = this.comparisons;
                        this.updateStats();
                        
                        await this.highlightBars(minIdx, j);
                        
                        if (this.array[j] < this.array[minIdx]) {
                            minIdx = j;
                        }
                    }
                    if (minIdx !== i) {
                        await this.swapBars(i, minIdx);
                    }
                }
            }

            // Insertion Sort
            async insertionSort() {
                const n = this.array.length;
                for (let i = 1; i < n; i++) {
                    let j = i;
                    while (j > 0) {
                        this.comparisons++;
                        this.comparisonsEl.textContent = this.comparisons;
                        this.updateStats();
                        
                        await this.highlightBars(j - 1, j);
                        
                        if (this.array[j - 1] > this.array[j]) {
                            await this.swapBars(j - 1, j);
                            j--;
                        } else {
                            break;
                        }
                    }
                }
            }

            // Merge Sort
            async mergeSort() {
                await this.mergeSortHelper(0, this.array.length - 1);
            }

            async mergeSortHelper(left, right) {
                if (left < right) {
                    const mid = Math.floor((left + right) / 2);
                    await this.mergeSortHelper(left, mid);
                    await this.mergeSortHelper(mid + 1, right);
                    await this.merge(left, mid, right);
                }
            }

            async merge(left, mid, right) {
                const leftArr = this.array.slice(left, mid + 1);
                const rightArr = this.array.slice(mid + 1, right + 1);
                
                let i = 0, j = 0, k = left;
                
                while (i < leftArr.length && j < rightArr.length) {
                    this.comparisons++;
                    this.comparisonsEl.textContent = this.comparisons;
                    this.updateStats();
                    
                    await this.highlightBars(k, k);
                    
                    if (leftArr[i] <= rightArr[j]) {
                        this.array[k] = leftArr[i];
                        i++;
                    } else {
                        this.array[k] = rightArr[j];
                        j++;
                    }
                    k++;
                }
                
                while (i < leftArr.length) {
                    this.array[k] = leftArr[i];
                    i++;
                    k++;
                }
                
                while (j < rightArr.length) {
                    this.array[k] = rightArr[j];
                    j++;
                    k++;
                }
                
                this.renderArray();
            }

            // Quick Sort
            async quickSort() {
                await this.quickSortHelper(0, this.array.length - 1);
            }

            async quickSortHelper(low, high) {
                if (low < high) {
                    const pivotIndex = await this.partition(low, high);
                    await this.quickSortHelper(low, pivotIndex - 1);
                    await this.quickSortHelper(pivotIndex + 1, high);
                }
            }

            async partition(low, high) {
                const pivot = this.array[high];
                let i = low - 1;
                
                for (let j = low; j < high; j++) {
                    this.comparisons++;
                    this.comparisonsEl.textContent = this.comparisons;
                    this.updateStats();
                    
                    await this.highlightBars(j, high);
                    
                    if (this.array[j] < pivot) {
                        i++;
                        if (i !== j) {
                            await this.swapBars(i, j);
                        }
                    }
                }
                
                await this.swapBars(i + 1, high);
                return i + 1;
            }

            // Heap Sort
            async heapSort() {
                const n = this.array.length;
                
                // Build max heap
                for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
                    await this.heapify(n, i);
                }
                
                // Extract elements from heap one by one
                for (let i = n - 1; i > 0; i--) {
                    await this.swapBars(0, i);
                    await this.heapify(i, 0);
                }
            }

            async heapify(n, i) {
                let largest = i;
                const left = 2 * i + 1;
                const right = 2 * i + 2;
                
                if (left < n) {
                    this.comparisons++;
                    this.comparisonsEl.textContent = this.comparisons;
                    this.updateStats();
                    
                    await this.highlightBars(largest, left);
                    
                    if (this.array[left] > this.array[largest]) {
                        largest = left;
                    }
                }
                
                if (right < n) {
                    this.comparisons++;
                    this.comparisonsEl.textContent = this.comparisons;
                    this.updateStats();
                    
                    await this.highlightBars(largest, right);
                    
                    if (this.array[right] > this.array[largest]) {
                        largest = right;
                    }
                }
                
                if (largest !== i) {
                    await this.swapBars(i, largest);
                    await this.heapify(n, largest);
                }
            }

            updateAlgorithmInfo() {
                const algorithm = this.algorithmSelect.value;
                const info = {
                    bubble: {
                        name: 'Bubble Sort',
                        timeComplexity: 'O(n²)',
                        spaceComplexity: 'O(1)',
                        stability: 'Yes',
                        description: 'Bubble Sort repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order. The pass through the list is repeated until the list is sorted.'
                    },
                    selection: {
                        name: 'Selection Sort',
                        timeComplexity: 'O(n²)',
                        spaceComplexity: 'O(1)',
                        stability: 'No',
                        description: 'Selection Sort finds the minimum element in the unsorted portion and swaps it with the first element of the unsorted portion.'
                    },
                    insertion: {
                        name: 'Insertion Sort',
                        timeComplexity: 'O(n²)',
                        spaceComplexity: 'O(1)',
                        stability: 'Yes',
                        description: 'Insertion Sort builds the final sorted array one element at a time by repeatedly taking the next element and inserting it into the correct position.'
                    },
                    merge: {
                        name: 'Merge Sort',
                        timeComplexity: 'O(n log n)',
                        spaceComplexity: 'O(n)',
                        stability: 'Yes',
                        description: 'Merge Sort divides the array into two halves, recursively sorts them, and then merges the sorted halves.'
                    },
                    quick: {
                        name: 'Quick Sort',
                        timeComplexity: 'O(n log n)',
                        spaceComplexity: 'O(log n)',
                        stability: 'No',
                        description: 'Quick Sort picks a pivot element and partitions the array around the pivot, then recursively sorts the sub-arrays.'
                    },
                    heap: {
                        name: 'Heap Sort',
                        timeComplexity: 'O(n log n)',
                        spaceComplexity: 'O(1)',
                        stability: 'No',
                        description: 'Heap Sort uses a binary heap data structure to sort elements by repeatedly extracting the maximum element from the heap.'
                    }
                };

                const selectedInfo = info[algorithm];
                this.algorithmName.textContent = selectedInfo.name;
                this.timeComplexity.textContent = selectedInfo.timeComplexity;
                this.spaceComplexity.textContent = selectedInfo.spaceComplexity;
                this.stability.textContent = selectedInfo.stability;
                this.description.textContent = selectedInfo.description;
            }
        }

        // Initialize the visualizer when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new SortingVisualizer();
        });
    </script>
</body>
</html>
