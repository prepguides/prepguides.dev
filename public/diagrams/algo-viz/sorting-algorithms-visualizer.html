<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sorting Algorithms Visualizer</title>
    <meta name="description" content="Interactive visualization of sorting algorithms including Bubble Sort, Selection Sort, Insertion Sort, Merge Sort, Quick Sort, and Heap Sort">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #6366f1;
            --secondary: #8b5cf6;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --dark: #1f2937;
            --light: #f3f4f6;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .main-container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 24px;
            overflow: hidden;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
        }

        header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white;
            padding: 40px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        header::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: repeating-linear-gradient(
                45deg,
                transparent,
                transparent 10px,
                rgba(255, 255, 255, 0.05) 10px,
                rgba(255, 255, 255, 0.05) 20px
            );
            animation: slide 20s linear infinite;
        }

        @keyframes slide {
            0% { transform: translate(0, 0); }
            100% { transform: translate(50px, 50px); }
        }

        h1 {
            font-size: 3em;
            margin-bottom: 10px;
            position: relative;
            z-index: 1;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
        }

        .subtitle {
            font-size: 1.2em;
            opacity: 0.95;
            position: relative;
            z-index: 1;
        }

        .algorithm-selector {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 15px;
            padding: 30px;
            background: var(--light);
            border-bottom: 2px solid #e5e7eb;
        }

        .algo-btn {
            padding: 12px 24px;
            border: 2px solid transparent;
            background: white;
            border-radius: 12px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .algo-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
        }

        .algo-btn.active {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white;
            border-color: var(--primary);
        }

        .algo-btn .complexity {
            display: block;
            font-size: 12px;
            font-weight: normal;
            margin-top: 4px;
            opacity: 0.8;
        }

        .content-area {
            padding: 40px;
        }

        .controls-section {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .control-btn {
            padding: 12px 28px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-btn.primary {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white;
        }

        .control-btn.secondary {
            background: var(--light);
            color: var(--dark);
        }

        .control-btn:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.15);
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 15px;
            background: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }

        .speed-control input[type="range"] {
            width: 150px;
            height: 6px;
            background: var(--light);
            outline: none;
            border-radius: 3px;
        }

        .speed-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
        }

        .size-control {
            display: flex;
            align-items: center;
            gap: 10px;
            background: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }

        .size-control select {
            padding: 6px 12px;
            border: 2px solid var(--light);
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
        }

        .visualization-area {
            background: white;
            border-radius: 16px;
            padding: 30px;
            margin: 30px 0;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            min-height: 400px;
        }

        .array-container {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            gap: 4px;
            height: 350px;
            padding: 20px;
            position: relative;
        }

        .bar {
            flex: 1;
            max-width: 60px;
            background: linear-gradient(180deg, #6366f1 0%, #4f46e5 100%);
            display: flex;
            align-items: flex-end;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 14px;
            padding-bottom: 8px;
            transition: all 0.3s ease;
            border-radius: 4px 4px 0 0;
            position: relative;
            min-width: 30px;
        }

        .bar.comparing {
            background: linear-gradient(180deg, var(--warning) 0%, #ea580c 100%);
            animation: pulse 0.5s ease-in-out;
        }

        .bar.swapping {
            background: linear-gradient(180deg, var(--danger) 0%, #dc2626 100%);
            animation: swap 0.5s ease-in-out;
        }

        .bar.sorted {
            background: linear-gradient(180deg, var(--success) 0%, #059669 100%);
        }

        .bar.pivot {
            background: linear-gradient(180deg, #8b5cf6 0%, #7c3aed 100%);
        }

        .bar.selected {
            background: linear-gradient(180deg, #ec4899 0%, #db2777 100%);
        }

        .bar.merging {
            background: linear-gradient(180deg, #14b8a6 0%, #0d9488 100%);
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        @keyframes swap {
            0%, 100% { transform: translateY(0) rotate(0); }
            25% { transform: translateY(-30px) rotate(-5deg); }
            75% { transform: translateY(-30px) rotate(5deg); }
        }

        .stats-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%);
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            transition: transform 0.3s ease;
        }

        .stat-card:hover {
            transform: translateY(-5px);
        }

        .stat-card h3 {
            color: var(--dark);
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
            opacity: 0.7;
        }

        .stat-card .value {
            font-size: 28px;
            font-weight: bold;
            color: var(--primary);
        }

        .info-section {
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            border-left: 4px solid var(--warning);
        }

        .info-section h3 {
            color: #92400e;
            margin-bottom: 10px;
        }

        .info-section p {
            color: #78350f;
            line-height: 1.6;
        }

        .code-display {
            background: #1e293b;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 12px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.8;
            overflow-x: auto;
            margin: 20px 0;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        }

        .code-highlight {
            background: rgba(250, 204, 21, 0.2);
            padding: 2px 6px;
            border-radius: 4px;
            color: #fbbf24;
        }

        .complexity-table {
            width: 100%;
            background: white;
            border-radius: 12px;
            overflow: hidden;
            margin: 30px 0;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
        }

        .complexity-table table {
            width: 100%;
            border-collapse: collapse;
        }

        .complexity-table th {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: 600;
        }

        .complexity-table td {
            padding: 15px;
            border-bottom: 1px solid var(--light);
        }

        .complexity-table tr:hover {
            background: var(--light);
        }

        footer {
            text-align: center;
            padding: 30px;
            background: var(--light);
            color: var(--dark);
            border-top: 2px solid #e5e7eb;
        }

        footer a {
            color: var(--primary);
            text-decoration: none;
            font-weight: 600;
        }

        footer a:hover {
            text-decoration: underline;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2em;
            }
            
            .algorithm-selector {
                padding: 20px;
            }
            
            .bar {
                min-width: 20px;
                font-size: 12px;
            }
            
            .controls-section {
                flex-direction: column;
                gap: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <header>
            <h1>🚀 Sorting Algorithms Visualizer</h1>
            <p class="subtitle">Interactive visualization of popular sorting algorithms</p>
        </header>

        <div class="algorithm-selector">
            <button class="algo-btn active" onclick="selectAlgorithm('bubble')">
                Bubble Sort
                <span class="complexity">O(n²)</span>
            </button>
            <button class="algo-btn" onclick="selectAlgorithm('selection')">
                Selection Sort
                <span class="complexity">O(n²)</span>
            </button>
            <button class="algo-btn" onclick="selectAlgorithm('insertion')">
                Insertion Sort
                <span class="complexity">O(n²)</span>
            </button>
            <button class="algo-btn" onclick="selectAlgorithm('merge')">
                Merge Sort
                <span class="complexity">O(n log n)</span>
            </button>
            <button class="algo-btn" onclick="selectAlgorithm('quick')">
                Quick Sort
                <span class="complexity">O(n log n)</span>
            </button>
            <button class="algo-btn" onclick="selectAlgorithm('heap')">
                Heap Sort
                <span class="complexity">O(n log n)</span>
            </button>
        </div>

        <div class="content-area">
            <div class="controls-section">
                <button class="control-btn primary" onclick="startSort()" id="startBtn">
                    <span>▶</span> Start Sorting
                </button>
                <button class="control-btn secondary" onclick="pauseSort()" id="pauseBtn">
                    <span>⏸</span> Pause
                </button>
                <button class="control-btn secondary" onclick="resetArray()">
                    <span>↻</span> Reset
                </button>
                <button class="control-btn secondary" onclick="generateNewArray()">
                    <span>🎲</span> New Array
                </button>
                
                <div class="speed-control">
                    <label>Speed:</label>
                    <input type="range" id="speedSlider" min="50" max="2000" value="500">
                    <span id="speedValue">500ms</span>
                </div>
                
                <div class="size-control">
                    <label>Size:</label>
                    <select id="sizeSelector" onchange="changeArraySize()">
                        <option value="10">10 elements</option>
                        <option value="15">15 elements</option>
                        <option value="20">20 elements</option>
                        <option value="30">30 elements</option>
                        <option value="50">50 elements</option>
                    </select>
                </div>
            </div>

            <div class="info-section" id="algorithmInfo">
                <h3>📚 About Bubble Sort</h3>
                <p>Bubble Sort repeatedly steps through the list, compares adjacent elements and swaps them if they're in the wrong order. The pass through the list is repeated until the list is sorted.</p>
            </div>

            <div class="visualization-area">
                <div class="array-container" id="arrayContainer"></div>
            </div>

            <div class="stats-panel">
                <div class="stat-card">
                    <h3>Comparisons</h3>
                    <div class="value" id="comparisons">0</div>
                </div>
                <div class="stat-card">
                    <h3>Swaps</h3>
                    <div class="value" id="swaps">0</div>
                </div>
                <div class="stat-card">
                    <h3>Array Accesses</h3>
                    <div class="value" id="arrayAccesses">0</div>
                </div>
                <div class="stat-card">
                    <h3>Time Elapsed</h3>
                    <div class="value" id="timeElapsed">0s</div>
                </div>
            </div>

            <div class="code-display" id="codeDisplay">
                <div id="currentCode">Select an algorithm and click Start to see the code execution...</div>
            </div>

            <div class="complexity-table">
                <table>
                    <thead>
                        <tr>
                            <th>Algorithm</th>
                            <th>Best Time</th>
                            <th>Average Time</th>
                            <th>Worst Time</th>
                            <th>Space</th>
                            <th>Stable</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Bubble Sort</strong></td>
                            <td>O(n)</td>
                            <td>O(n²)</td>
                            <td>O(n²)</td>
                            <td>O(1)</td>
                            <td>✅ Yes</td>
                        </tr>
                        <tr>
                            <td><strong>Selection Sort</strong></td>
                            <td>O(n²)</td>
                            <td>O(n²)</td>
                            <td>O(n²)</td>
                            <td>O(1)</td>
                            <td>❌ No</td>
                        </tr>
                        <tr>
                            <td><strong>Insertion Sort</strong></td>
                            <td>O(n)</td>
                            <td>O(n²)</td>
                            <td>O(n²)</td>
                            <td>O(1)</td>
                            <td>✅ Yes</td>
                        </tr>
                        <tr>
                            <td><strong>Merge Sort</strong></td>
                            <td>O(n log n)</td>
                            <td>O(n log n)</td>
                            <td>O(n log n)</td>
                            <td>O(n)</td>
                            <td>✅ Yes</td>
                        </tr>
                        <tr>
                            <td><strong>Quick Sort</strong></td>
                            <td>O(n log n)</td>
                            <td>O(n log n)</td>
                            <td>O(n²)</td>
                            <td>O(log n)</td>
                            <td>❌ No</td>
                        </tr>
                        <tr>
                            <td><strong>Heap Sort</strong></td>
                            <td>O(n log n)</td>
                            <td>O(n log n)</td>
                            <td>O(n log n)</td>
                            <td>O(1)</td>
                            <td>❌ No</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <footer>
            <p>Created with ❤️ for Learning | 
            <a href="https://github.com">View on GitHub</a> | 
            <a href="#" onclick="alert('Replace with your GitHub Pages URL')">Share</a></p>
        </footer>
    </div>

    <script>
        // Global variables
        let array = [];
        let originalArray = [];
        let currentAlgorithm = 'bubble';
        let isSorting = false;
        let isPaused = false;
        let delay = 500;
        let comparisons = 0;
        let swaps = 0;
        let arrayAccesses = 0;
        let startTime = null;
        let animationId = null;

        // Algorithm information
        const algorithmInfo = {
            bubble: {
                name: 'Bubble Sort',
                description: 'Bubble Sort repeatedly steps through the list, compares adjacent elements and swaps them if they\'re in the wrong order. The pass through the list is repeated until the list is sorted.',
                code: `for (int i = 0; i < n - 1; i++) {
    for (int j = 0; j < n - i - 1; j++) {
        if (arr[j] > arr[j + 1]) {
            swap(arr[j], arr[j + 1]);
        }
    }
}`
            },
            selection: {
                name: 'Selection Sort',
                description: 'Selection Sort divides the array into sorted and unsorted regions. It repeatedly finds the minimum element from the unsorted region and moves it to the sorted region.',
                code: `for (int i = 0; i < n - 1; i++) {
    int minIndex = i;
    for (int j = i + 1; j < n; j++) {
        if (arr[j] < arr[minIndex]) {
            minIndex = j;
        }
    }
    swap(arr[i], arr[minIndex]);
}`
            },
            insertion: {
                name: 'Insertion Sort',
                description: 'Insertion Sort builds the final sorted array one item at a time. It takes each element and inserts it into its correct position among the previously sorted elements.',
                code: `for (int i = 1; i < n; i++) {
    int key = arr[i];
    int j = i - 1;
    while (j >= 0 && arr[j] > key) {
        arr[j + 1] = arr[j];
        j--;
    }
    arr[j + 1] = key;
}`
            },
            merge: {
                name: 'Merge Sort',
                description: 'Merge Sort is a divide-and-conquer algorithm that divides the array into halves, recursively sorts them, and then merges the sorted halves back together.',
                code: `mergeSort(arr, left, right) {
    if (left < right) {
        int mid = (left + right) / 2;
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);
        merge(arr, left, mid, right);
    }
}`
            },
            quick: {
                name: 'Quick Sort',
                description: 'Quick Sort picks a pivot element and partitions the array around it, placing smaller elements before it and larger elements after it. It then recursively sorts the sub-arrays.',
                code: `quickSort(arr, low, high) {
    if (low < high) {
        int pivot = partition(arr, low, high);
        quickSort(arr, low, pivot - 1);
        quickSort(arr, pivot + 1, high);
    }
}`
            },
            heap: {
                name: 'Heap Sort',
                description: 'Heap Sort builds a max heap from the array, then repeatedly extracts the maximum element and places it at the end of the sorted portion.',
                code: `// Build max heap
for (int i = n/2 - 1; i >= 0; i--) {
    heapify(arr, n, i);
}
// Extract elements
for (int i = n-1; i > 0; i--) {
    swap(arr[0], arr[i]);
    heapify(arr, i, 0);
}`
            }
        };

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            generateNewArray();
            updateAlgorithmInfo();
            
            // Speed slider
            const speedSlider = document.getElementById('speedSlider');
            speedSlider.addEventListener('input', (e) => {
                delay = parseInt(e.target.value);
                document.getElementById('speedValue').textContent = `${delay}ms`;
            });
        });

        function selectAlgorithm(algo) {
            if (isSorting) return;
            
            currentAlgorithm = algo;
            
            // Update UI
            document.querySelectorAll('.algo-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            updateAlgorithmInfo();
            resetArray();
        }

        function updateAlgorithmInfo() {
            const info = algorithmInfo[currentAlgorithm];
            document.getElementById('algorithmInfo').innerHTML = `
                <h3>📚 About ${info.name}</h3>
                <p>${info.description}</p>
            `;
        }

        function generateNewArray() {
            if (isSorting) return;
            
            const size = parseInt(document.getElementById('sizeSelector').value);
            array = [];
            
            for (let i = 0; i < size; i++) {
                array.push(Math.floor(Math.random() * 90) + 10);
            }
            
            originalArray = [...array];
            resetStats();
            renderArray();
        }

        function changeArraySize() {
            generateNewArray();
        }

        function resetArray() {
            if (isSorting) {
                isSorting = false;
                isPaused = false;
            }
            
            array = [...originalArray];
            resetStats();
            renderArray();
            document.getElementById('startBtn').innerHTML = '<span>▶</span> Start Sorting';
        }

        function resetStats() {
            comparisons = 0;
            swaps = 0;
            arrayAccesses = 0;
            startTime = null;
            updateStats();
            document.getElementById('currentCode').textContent = 'Select an algorithm and click Start to see the code execution...';
        }

        function updateStats() {
            document.getElementById('comparisons').textContent = comparisons;
            document.getElementById('swaps').textContent = swaps;
            document.getElementById('arrayAccesses').textContent = arrayAccesses;
            
            if (startTime) {
                const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
                document.getElementById('timeElapsed').textContent = `${elapsed}s`;
            } else {
                document.getElementById('timeElapsed').textContent = '0s';
            }
        }

        function renderArray(highlightIndices = [], highlightType = '') {
            const container = document.getElementById('arrayContainer');
            container.innerHTML = '';
            
            const maxVal = Math.max(...array);
            
            array.forEach((val, index) => {
                const bar = document.createElement('div');
                bar.className = 'bar';
                
                if (highlightIndices.includes(index)) {
                    bar.classList.add(highlightType);
                }
                
                bar.style.height = `${(val / maxVal) * 300}px`;
                bar.textContent = val;
                
                container.appendChild(bar);
            });
            
            arrayAccesses += array.length;
            updateStats();
        }

        async function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function updateCode(line) {
            const info = algorithmInfo[currentAlgorithm];
            document.getElementById('currentCode').innerHTML = `
                <strong>${info.name} Code:</strong><br>
                <pre>${info.code}</pre>
                <br>
                <span class="code-highlight">Current: ${line}</span>
            `;
        }

        // Sorting algorithms
        async function bubbleSort() {
            const n = array.length;
            
            for (let i = 0; i < n - 1; i++) {
                let swapped = false;
                
                for (let j = 0; j < n - i - 1; j++) {
                    if (!isSorting || isPaused) return;
                    
                    renderArray([j, j + 1], 'comparing');
                    updateCode(`Comparing arr[${j}]=${array[j]} with arr[${j+1}]=${array[j+1]}`);
                    comparisons++;
                    updateStats();
                    await sleep(delay);
                    
                    if (array[j] > array[j + 1]) {
                        renderArray([j, j + 1], 'swapping');
                        await sleep(delay);
                        
                        [array[j], array[j + 1]] = [array[j + 1], array[j]];
                        swaps++;
                        swapped = true;
                        updateStats();
                    }
                }
                
                if (!swapped) break;
            }
            
            if (isSorting && !isPaused) {
                renderArray(array.map((_, i) => i), 'sorted');
                updateCode('Sorting complete!');
            }
        }

        async function selectionSort() {
            const n = array.length;
            
            for (let i = 0; i < n - 1; i++) {
                if (!isSorting || isPaused) return;
                
                let minIndex = i;
                renderArray([i], 'selected');
                updateCode(`Finding minimum from index ${i}`);
                await sleep(delay);
                
                for (let j = i + 1; j < n; j++) {
                    if (!isSorting || isPaused) return;
                    
                    renderArray([minIndex, j], 'comparing');
                    comparisons++;
                    updateStats();
                    await sleep(delay);
                    
                    if (array[j] < array[minIndex]) {
                        minIndex = j;
                    }
                }
                
                if (minIndex !== i) {
                    renderArray([i, minIndex], 'swapping');
                    updateCode(`Swapping arr[${i}]=${array[i]} with arr[${minIndex}]=${array[minIndex]}`);
                    await sleep(delay);
                    
                    [array[i], array[minIndex]] = [array[minIndex], array[i]];
                    swaps++;
                    updateStats();
                }
            }
            
            if (isSorting && !isPaused) {
                renderArray(array.map((_, i) => i), 'sorted');
                updateCode('Sorting complete!');
            }
        }

        async function insertionSort() {
            const n = array.length;
            
            for (let i = 1; i < n; i++) {
                if (!isSorting || isPaused) return;
                
                let key = array[i];
                let j = i - 1;
                
                renderArray([i], 'selected');
                updateCode(`Inserting ${key} into sorted portion`);
                await sleep(delay);
                
                while (j >= 0 && array[j] > key) {
                    if (!isSorting || isPaused) return;
                    
                    renderArray([j, j + 1], 'comparing');
                    comparisons++;
                    updateStats();
                    await sleep(delay);
                    
                    array[j + 1] = array[j];
                    j--;
                    
                    renderArray();
                    await sleep(delay / 2);
                }
                
                array[j + 1] = key;
                swaps++;
                updateStats();
                renderArray();
                await sleep(delay);
            }
            
            if (isSorting && !isPaused) {
                renderArray(array.map((_, i) => i), 'sorted');
                updateCode('Sorting complete!');
            }
        }

        async function mergeSort() {
            async function mergeSortHelper(left, right) {
                if (left >= right) return;
                if (!isSorting || isPaused) return;
                
                const mid = Math.floor((left + right) / 2);
                
                updateCode(`Dividing array from ${left} to ${right}, mid=${mid}`);
                await sleep(delay);
                
                await mergeSortHelper(left, mid);
                await mergeSortHelper(mid + 1, right);
                await merge(left, mid, right);
            }
            
            async function merge(left, mid, right) {
                const leftArr = array.slice(left, mid + 1);
                const rightArr = array.slice(mid + 1, right + 1);
                
                let i = 0, j = 0, k = left;
                
                while (i < leftArr.length && j < rightArr.length) {
                    if (!isSorting || isPaused) return;
                    
                    renderArray([k], 'merging');
                    comparisons++;
                    updateStats();
                    updateCode(`Merging: comparing ${leftArr[i]} and ${rightArr[j]}`);
                    await sleep(delay);
                    
                    if (leftArr[i] <= rightArr[j]) {
                        array[k] = leftArr[i];
                        i++;
                    } else {
                        array[k] = rightArr[j];
                        j++;
                    }
                    k++;
                }
                
                while (i < leftArr.length) {
                    if (!isSorting || isPaused) return;
                    array[k] = leftArr[i];
                    i++;
                    k++;
                    renderArray();
                    await sleep(delay / 2);
                }
                
                while (j < rightArr.length) {
                    if (!isSorting || isPaused) return;
                    array[k] = rightArr[j];
                    j++;
                    k++;
                    renderArray();
                    await sleep(delay / 2);
                }
                
                swaps += (right - left + 1);
                updateStats();
            }
            
            await mergeSortHelper(0, array.length - 1);
            
            if (isSorting && !isPaused) {
                renderArray(array.map((_, i) => i), 'sorted');
                updateCode('Sorting complete!');
            }
        }

        async function quickSort() {
            async function quickSortHelper(low, high) {
                if (low >= high) return;
                if (!isSorting || isPaused) return;
                
                const pivotIndex = await partition(low, high);
                await quickSortHelper(low, pivotIndex - 1);
                await quickSortHelper(pivotIndex + 1, high);
            }
            
            async function partition(low, high) {
                const pivot = array[high];
                let i = low - 1;
                
                renderArray([high], 'pivot');
                updateCode(`Pivot selected: ${pivot} at index ${high}`);
                await sleep(delay);
                
                for (let j = low; j < high; j++) {
                    if (!isSorting || isPaused) return i + 1;
                    
                    renderArray([j, high], 'comparing');
                    comparisons++;
                    updateStats();
                    await sleep(delay);
                    
                    if (array[j] <= pivot) {
                        i++;
                        if (i !== j) {
                            renderArray([i, j], 'swapping');
                            await sleep(delay);
                            
                            [array[i], array[j]] = [array[j], array[i]];
                            swaps++;
                            updateStats();
                        }
                    }
                }
                
                renderArray([i + 1, high], 'swapping');
                await sleep(delay);
                
                [array[i + 1], array[high]] = [array[high], array[i + 1]];
                swaps++;
                updateStats();
                
                return i + 1;
            }
            
            await quickSortHelper(0, array.length - 1);
            
            if (isSorting && !isPaused) {
                renderArray(array.map((_, i) => i), 'sorted');
                updateCode('Sorting complete!');
            }
        }

        async function heapSort() {
            async function heapify(n, i) {
                let largest = i;
                const left = 2 * i + 1;
                const right = 2 * i + 2;
                
                updateCode(`Heapifying at index ${i}`);
                
                if (left < n) {
                    renderArray([largest, left], 'comparing');
                    comparisons++;
                    updateStats();
                    await sleep(delay);
                    
                    if (array[left] > array[largest]) {
                        largest = left;
                    }
                }
                
                if (right < n) {
                    renderArray([largest, right], 'comparing');
                    comparisons++;
                    updateStats();
                    await sleep(delay);
                    
                    if (array[right] > array[largest]) {
                        largest = right;
                    }
                }
                
                if (largest !== i) {
                    renderArray([i, largest], 'swapping');
                    await sleep(delay);
                    
                    [array[i], array[largest]] = [array[largest], array[i]];
                    swaps++;
                    updateStats();
                    
                    await heapify(n, largest);
                }
            }
            
            const n = array.length;
            
            // Build max heap
            updateCode('Building max heap...');
            for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
                if (!isSorting || isPaused) return;
                await heapify(n, i);
            }
            
            // Extract elements
            updateCode('Extracting elements from heap...');
            for (let i = n - 1; i > 0; i--) {
                if (!isSorting || isPaused) return;
                
                renderArray([0, i], 'swapping');
                await sleep(delay);
                
                [array[0], array[i]] = [array[i], array[0]];
                swaps++;
                updateStats();
                
                await heapify(i, 0);
            }
            
            if (isSorting && !isPaused) {
                renderArray(array.map((_, i) => i), 'sorted');
                updateCode('Sorting complete!');
            }
        }

        async function startSort() {
            if (isSorting && !isPaused) return;
            
            if (isPaused) {
                isPaused = false;
                document.getElementById('startBtn').innerHTML = '<span>▶</span> Sorting...';
                return;
            }
            
            isSorting = true;
            isPaused = false;
            startTime = Date.now();
            document.getElementById('startBtn').innerHTML = '<span>▶</span> Sorting...';
            
            // Start the timer update
            animationId = setInterval(updateStats, 100);
            
            switch (currentAlgorithm) {
                case 'bubble':
                    await bubbleSort();
                    break;
                case 'selection':
                    await selectionSort();
                    break;
                case 'insertion':
                    await insertionSort();
                    break;
                case 'merge':
                    await mergeSort();
                    break;
                case 'quick':
                    await quickSort();
                    break;
                case 'heap':
                    await heapSort();
                    break;
            }
            
            isSorting = false;
            clearInterval(animationId);
            document.getElementById('startBtn').innerHTML = '<span>▶</span> Start Sorting';
        }

        function pauseSort() {
            if (!isSorting) return;
            
            isPaused = !isPaused;
            if (isPaused) {
                document.getElementById('startBtn').innerHTML = '<span>▶</span> Resume';
            } else {
                document.getElementById('startBtn').innerHTML = '<span>▶</span> Sorting...';
            }
        }
    </script>
</body>
</html>